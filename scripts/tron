#!/bin/bash
# tron - Unified CLI for Tron development and deployment
#
# Usage: tron <command> [options]
#
# Commands:
#   dev        Start beta server (-b to build, -t to tail, -k to kill, -r to restart)
#   deploy     Build, test, and deploy (append 'beta' for beta)
#   install    Initial production setup (launchd + CLI)
#   rollback   Restore previous deployment
#   setup      First-time project setup
#   status     Show service status and health
#   start/stop/restart  Manage service (append 'beta' for beta)
#   login      OAuth login for Claude (--label for multi-account)
#   logs       Query database logs
#   errors     Show recent errors
#   uninstall  Remove service (preserves data)
#   help       Show this help message
#
# Dev workflows (use directly):
#   bun run build       Build all packages
#   bun run test        Run all tests
#   bun run lint        Lint source
#   bun run typecheck   Type check

set -e

#=============================================================================
# SECTION 1: CONFIGURATION
# All constants, paths, and environment defaults
#=============================================================================

# Resolve symlinks to get the real script location
SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SOURCE" ]; do
    DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"

# Data directories
TRON_HOME="${TRON_DATA_DIR:-$HOME/.tron}"
INSTALL_DIR="$TRON_HOME/app"
BIN_DIR="$HOME/.local/bin"

# Service configuration
PLIST_NAME="com.tron.server"
PLIST_PATH="$HOME/Library/LaunchAgents/$PLIST_NAME.plist"

# Port configuration
PROD_WS_PORT=8080
PROD_HEALTH_PORT=8081
BETA_WS_PORT=8082
BETA_HEALTH_PORT=8083

# File paths
PROD_LOG_FILE="$INSTALL_DIR/server.log"
DEPLOYED_COMMIT_FILE="$INSTALL_DIR/deployed-commit"
BETA_VERIFIED_FILE="$INSTALL_DIR/beta-deploy-verified.json"
DEPLOY_LOCK_FILE="$TRON_HOME/deploy.lock"

#=============================================================================
# SECTION 2: UTILITY FUNCTIONS
# Colors, printing, common helpers
#=============================================================================

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# Print helpers
print_status()  { echo -e "${BLUE}▸${NC} $1"; }
print_success() { echo -e "${GREEN}✓${NC} $1"; }
print_error()   { echo -e "${RED}✗${NC} $1"; }
print_warning() { echo -e "${YELLOW}!${NC} $1"; }
print_header()  { echo -e "\n${CYAN}$1${NC}\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"; }

require_project_dir() {
    if [ ! -f "$PROJECT_DIR/package.json" ]; then
        print_error "Not in project directory: $PROJECT_DIR"
        exit 1
    fi
}

require_installed() {
    if [ ! -f "$PLIST_PATH" ]; then
        print_error "Tron not installed. Run: tron install"
        exit 1
    fi
}

confirm_action() {
    read -p "$1 (y/N) " -n 1 -r
    echo
    [[ $REPLY =~ ^[Yy]$ ]]
}

ensure_tron_home() {
    mkdir -p "$TRON_HOME"/{database,mods,notes,skills,artifacts/canvases}
    mkdir -p "$TRON_HOME"/mods/apns

    # Migrate legacy db/ → database/
    if [ -d "$TRON_HOME/db" ] && [ ! -L "$TRON_HOME/db" ]; then
        mv "$TRON_HOME/db"/* "$TRON_HOME/database/" 2>/dev/null
        rmdir "$TRON_HOME/db" 2>/dev/null
    fi
}

get_bun_path() {
    if [ -x "$HOME/.bun/bin/bun" ]; then
        echo "$HOME/.bun/bin/bun"
    else
        which bun
    fi
}

#=============================================================================
# SECTION 3: BUILD FUNCTIONS
# Workspace building, production bundling, native module handling
#=============================================================================

build_workspace() {
    print_status "Building workspace packages..."

    # Ensure bun is in PATH
    export PATH="$HOME/.bun/bin:$PATH"

    (cd "$PROJECT_DIR/packages/agent" && bun run build) || { print_error "Failed to build @tron/agent"; exit 1; }
    (cd "$PROJECT_DIR/packages/tui" && bun run build) || { print_error "Failed to build @tron/tui"; exit 1; }
    (cd "$PROJECT_DIR/packages/chat-web" && bun run build) || { print_error "Failed to build @tron/chat-web"; exit 1; }

    print_success "Workspace built successfully"
}

# Build production artifact: tsc output + isolated node_modules
#
# Mirrors exactly what works in beta/dev (bun + tsc multi-file output + normal
# module resolution). No esbuild — its CJS conversion breaks ws send callbacks
# under Bun and requires constant workarounds for packages with dynamic requires.
build_production() {
    print_status "Building production artifact..."

    cd "$PROJECT_DIR"

    build_workspace
    setup_browser

    rm -rf dist/prod
    mkdir -p dist/prod

    # Copy tsc output (identical to what beta runs from packages/agent/dist/)
    cp -r packages/agent/dist/* dist/prod/

    # Generate package.json with production deps from agent's package.json
    bun -e "
      const pkg = require('./packages/agent/package.json');
      const prod = {
        name: 'tron-server-prod',
        version: pkg.version,
        type: 'module',
        dependencies: pkg.dependencies,
      };
      process.stdout.write(JSON.stringify(prod, null, 2) + '\n');
    " > dist/prod/package.json

    # Install production dependencies (bun resolves all transitive deps)
    print_status "Installing production dependencies..."
    (cd dist/prod && bun install --production)

    local total_size=$(du -sh dist/prod | awk '{print $1}')
    print_success "Production build complete ($total_size)"
}

run_tests() {
    print_status "Running tests..."
    cd "$PROJECT_DIR"
    if bun run test 2>&1; then
        print_success "Tests passed"
        return 0
    else
        return 1
    fi
}

# Set up Python venv + ffmpeg for transcription service (idempotent)
setup_transcription_sidecar() {
    local sidecar_dir="$PROJECT_DIR/services/transcribe"
    local venv_dir="$sidecar_dir/.venv"
    local venv_python="$venv_dir/bin/python"
    local requirements="$sidecar_dir/requirements.txt"

    # Skip if requirements.txt doesn't exist
    if [ ! -f "$requirements" ]; then
        print_warning "Transcription requirements.txt not found, skipping sidecar setup"
        return 0
    fi

    # Ensure ffmpeg is installed (required for audio format conversion)
    if ! command -v ffmpeg &> /dev/null; then
        print_status "ffmpeg not found, installing via Homebrew..."
        if command -v brew &> /dev/null; then
            brew install ffmpeg
            if [ $? -eq 0 ]; then
                print_success "ffmpeg installed"
            else
                print_warning "Failed to install ffmpeg via Homebrew"
                print_warning "Transcription may fail for some audio formats"
            fi
        else
            print_warning "Homebrew not found, cannot install ffmpeg"
            print_warning "Install ffmpeg manually: brew install ffmpeg"
        fi
    fi

    # Check if venv exists and has parakeet-mlx installed
    if [ -f "$venv_python" ]; then
        if "$venv_python" -c "import parakeet_mlx" 2>/dev/null; then
            print_success "Transcription sidecar already configured"
            return 0
        fi
        print_status "Transcription venv exists but missing dependencies, reinstalling..."
    else
        print_status "Setting up transcription sidecar..."
    fi

    # Find a suitable Python interpreter (3.10+ required for MLX)
    local python_bin=""
    for candidate in python3.12 python3.11 python3.10 python3; do
        if command -v "$candidate" &> /dev/null; then
            python_bin="$candidate"
            break
        fi
    done

    if [ -z "$python_bin" ]; then
        print_warning "Python 3.10+ not found, skipping transcription sidecar setup"
        print_warning "Install Python 3.10+ to enable voice transcription"
        return 0
    fi

    # Create venv if it doesn't exist
    if [ ! -d "$venv_dir" ]; then
        print_status "Creating Python venv with $python_bin..."
        "$python_bin" -m venv "$venv_dir"
        if [ $? -ne 0 ]; then
            print_error "Failed to create Python venv"
            return 1
        fi
    fi

    # Install dependencies
    print_status "Installing transcription dependencies (this may take a moment)..."
    "$venv_python" -m pip install --upgrade pip -q
    "$venv_python" -m pip install -r "$requirements" -q
    if [ $? -ne 0 ]; then
        print_error "Failed to install transcription dependencies"
        return 1
    fi

    print_success "Transcription sidecar configured"
    return 0
}

# Ensure Playwright chromium headless shell is installed (idempotent)
setup_browser() {
    # Check if playwright-core can find its browser
    if bunx playwright-core browser-versions chromium 2>/dev/null | grep -q "chromium"; then
        local install_path="$HOME/Library/Caches/ms-playwright"
        if [ -d "$install_path" ] && ls "$install_path"/chromium_headless_shell-* &>/dev/null; then
            print_success "Playwright browser already installed"
            return 0
        fi
    fi

    print_status "Installing Playwright chromium headless shell..."
    if bunx playwright-core install chromium --only-shell 2>&1; then
        print_success "Playwright browser ready"
    else
        print_warning "Failed to install Playwright browser (BrowseTheWeb tool will be unavailable)"
    fi
}

#=============================================================================
# SECTION 4: SERVICE FUNCTIONS
# launchd management, health checks, port detection
#=============================================================================

service_is_running() {
    launchctl list 2>/dev/null | grep -q "$PLIST_NAME"
}

get_service_pid() {
    lsof -t -i :$PROD_WS_PORT -sTCP:LISTEN 2>/dev/null || true
}

get_beta_pid() {
    lsof -t -i :$BETA_WS_PORT -sTCP:LISTEN 2>/dev/null || true
}

beta_is_running() {
    [ -n "$(get_beta_pid)" ]
}

beta_start() {
    require_project_dir

    if beta_is_running; then
        print_warning "Beta service is already running (PID: $(get_beta_pid))"
        return 0
    fi

    print_status "Starting beta service..."

    TRON_WS_PORT=$BETA_WS_PORT \
    TRON_HEALTH_PORT=$BETA_HEALTH_PORT \
    TRON_BUILD_TIER=beta \
    TRON_EVENT_STORE_DB="$TRON_HOME/database/beta.db" \
    TRON_REPO_ROOT="$PROJECT_DIR" \
    LOG_LEVEL="${LOG_LEVEL:-trace}" \
    NODE_ENV=development \
    bun "$PROJECT_DIR/packages/agent/dist/interface/server.js" >/dev/null 2>&1 &
    local pid=$!

    sleep 2

    if kill -0 $pid 2>/dev/null; then
        print_success "Beta service started (PID: $pid)"
        echo "  WebSocket: ws://localhost:$BETA_WS_PORT/ws"
        echo "  Health:    http://localhost:$BETA_HEALTH_PORT/health"
    else
        print_error "Beta service failed to start"
        return 1
    fi
}

beta_stop() {
    local beta_pid=$(get_beta_pid)
    if [ -z "$beta_pid" ]; then
        print_warning "Beta service is not running"
        return 0
    fi

    print_status "Stopping beta service..."
    kill "$beta_pid" 2>/dev/null
    sleep 1

    if [ -z "$(get_beta_pid)" ]; then
        print_success "Beta service stopped"
    else
        print_error "Failed to stop beta service"
        return 1
    fi
}

service_start() {
    if [ ! -f "$PLIST_PATH" ]; then
        print_error "Service not installed. Run: tron install"
        return 1
    fi

    print_status "Starting production service..."
    launchctl load "$PLIST_PATH"
    sleep 2

    if service_is_running; then
        local pid=$(get_service_pid)
        print_success "Production service started (PID: ${pid:-unknown})"
        echo "  WebSocket: ws://localhost:$PROD_WS_PORT/ws"
        echo "  Health:    http://localhost:$PROD_HEALTH_PORT/health"
    else
        print_error "Failed to start service. Check: tron errors"
        return 1
    fi
}

service_stop() {
    if ! service_is_running; then
        print_warning "Production service is not running"
        return 0
    fi

    print_status "Stopping production service..."
    launchctl unload "$PLIST_PATH"
    sleep 1

    if ! service_is_running; then
        print_success "Production service stopped"
    else
        print_error "Failed to stop service"
        return 1
    fi
}

health_check() {
    local port="${1:-$PROD_HEALTH_PORT}"
    local response
    response=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:$port/health" 2>/dev/null || echo "000")
    [ "$response" = "200" ]
}

create_launchd_plist() {
    local bun_path=$(get_bun_path)

    cat > "$PLIST_PATH" << PLIST
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>$PLIST_NAME</string>

    <key>ProgramArguments</key>
    <array>
        <string>/bin/sh</string>
        <string>-c</string>
        <string>exec "$bun_path" "$INSTALL_DIR/interface/server.js" >> "$PROD_LOG_FILE" 2>&amp;1</string>
    </array>

    <key>WorkingDirectory</key>
    <string>$INSTALL_DIR</string>

    <key>RunAtLoad</key>
    <true/>

    <key>KeepAlive</key>
    <dict>
        <key>SuccessfulExit</key>
        <false/>
        <key>Crashed</key>
        <true/>
    </dict>

    <key>ThrottleInterval</key>
    <integer>10</integer>

    <key>EnvironmentVariables</key>
    <dict>
        <key>NODE_ENV</key>
        <string>production</string>
        <key>TRON_BUILD_TIER</key>
        <string>prod</string>
        <key>HOME</key>
        <string>$HOME</string>
        <key>PATH</key>
        <string>$(dirname "$bun_path"):/usr/local/bin:/usr/bin:/bin</string>
        <key>TRON_DATA_DIR</key>
        <string>$TRON_HOME</string>
        <key>TRON_REPO_ROOT</key>
        <string>$PROJECT_DIR</string>
        <key>TRON_WS_PORT</key>
        <string>$PROD_WS_PORT</string>
        <key>TRON_HEALTH_PORT</key>
        <string>$PROD_HEALTH_PORT</string>
        <key>LOG_LEVEL</key>
        <string>info</string>
    </dict>

    <key>SoftResourceLimits</key>
    <dict>
        <key>NumberOfFiles</key>
        <integer>4096</integer>
    </dict>
</dict>
</plist>
PLIST
}

#=============================================================================
# SECTION 5: LOG FUNCTIONS
# Database log queries, file log tailing, error display
#=============================================================================

query_logs() {
    local tier="prod"
    local level=""
    local output=""
    local limit=50
    local tail_mode=false
    local session=""
    local search=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -l|--level)   level="$2"; shift 2 ;;
            -o|--output)  output="$2"; shift 2 ;;
            -n|--limit)   limit="$2"; shift 2 ;;
            -t|--tail)    tail_mode=true; shift ;;
            -s|--session) session="$2"; shift 2 ;;
            -q|--search)  search="$2"; shift 2 ;;
            beta|prod)    tier="$1"; shift ;;
            -h|--help)
                echo ""
                echo -e "${CYAN}tron logs${NC} - Query database logs"
                echo ""
                echo "Usage: tron logs [options] [prod|beta]"
                echo ""
                echo "Options:"
                echo "  -l, --level LEVEL    Filter by level (trace/debug/info/warn/error/fatal)"
                echo "  -n, --limit N        Number of logs to show (default: 50)"
                echo "  -o, --output FILE    Write output to file"
                echo "  -s, --session ID     Filter by session ID"
                echo "  -q, --search TEXT    Search log messages (FTS)"
                echo "  -t, --tail           Tail file logs instead of querying database"
                echo ""
                echo "Examples:"
                echo "  tron logs                     # Latest 50 logs"
                echo "  tron logs -l error            # Only errors"
                echo "  tron logs -l warn -n 100      # Last 100 warnings+"
                echo "  tron logs -t                  # Tail file logs"
                echo "  tron logs beta -l info        # Beta database logs"
                echo ""
                return 0
                ;;
            *) shift ;;
        esac
    done

    # Tail mode - use prod file log
    if [ "$tail_mode" = true ]; then
        if [ ! -f "$PROD_LOG_FILE" ]; then
            print_error "Log file not found: $PROD_LOG_FILE"
            return 1
        fi
        echo -e "${BLUE}Tailing prod log${NC}"
        echo -e "${DIM}$PROD_LOG_FILE${NC}"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        tail -f "$PROD_LOG_FILE"
        return 0
    fi

    # Database mode
    local db_path="$TRON_HOME/database/prod.db"
    [ "$tier" = "beta" ] && db_path="$TRON_HOME/database/beta.db"

    if [ ! -f "$db_path" ]; then
        print_error "Database not found: $db_path"
        echo "The server may not have been started yet."
        return 1
    fi

    # Check if logs table exists
    local table_exists
    table_exists=$(sqlite3 "$db_path" "SELECT name FROM sqlite_master WHERE type='table' AND name='logs';" 2>/dev/null)
    if [ -z "$table_exists" ]; then
        print_error "Logs table not found in database"
        return 1
    fi

    # Build SQL query
    local conditions=()

    if [ -n "$level" ]; then
        local level_num
        case "$level" in
            trace) level_num=10 ;;
            debug) level_num=20 ;;
            info)  level_num=30 ;;
            warn)  level_num=40 ;;
            error) level_num=50 ;;
            fatal) level_num=60 ;;
            *)
                print_error "Invalid level: $level (valid: trace/debug/info/warn/error/fatal)"
                return 1
                ;;
        esac
        conditions+=("level_num >= $level_num")
    fi

    [ -n "$session" ] && conditions+=("session_id LIKE '%$session%'")

    local where_clause=""
    if [ ${#conditions[@]} -gt 0 ]; then
        where_clause="WHERE $(IFS=' AND '; echo "${conditions[*]}")"
    fi

    local sql
    if [ -n "$search" ]; then
        sql="SELECT l.timestamp, l.level, l.component, l.message, l.session_id, l.error_message
             FROM logs l
             JOIN logs_fts f ON l.id = f.log_id
             WHERE logs_fts MATCH '${search//\'/\'\'}'
             ${where_clause:+AND ${where_clause#WHERE }}
             ORDER BY l.timestamp DESC
             LIMIT $limit"
    else
        sql="SELECT timestamp, level, component, message, session_id, error_message
             FROM logs
             $where_clause
             ORDER BY timestamp DESC
             LIMIT $limit"
    fi

    local result
    result=$(sqlite3 -separator '|' "$db_path" "$sql" 2>&1)

    if [ $? -ne 0 ]; then
        print_error "Database query failed: $result"
        return 1
    fi

    if [ -z "$result" ]; then
        echo -e "${DIM}No logs found matching criteria${NC}"
        return 0
    fi

    # Output
    if [ -n "$output" ]; then
        echo "$result" | while IFS='|' read -r ts lvl comp msg sess err; do
            local line="${ts} ${lvl} [${comp}] ${msg}"
            [ -n "$sess" ] && line="$line (${sess})"
            [ -n "$err" ] && line="$line | Error: $err"
            echo "$line"
        done > "$output"
        print_success "Wrote $(wc -l < "$output" | tr -d ' ') logs to $output"
    else
        echo -e "${CYAN}Database Logs ($tier)${NC}"
        echo -e "${DIM}Database: $db_path${NC}"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "$result" | while IFS='|' read -r ts lvl comp msg sess err; do
            local color=""
            case "$lvl" in
                trace|debug) color="$DIM" ;;
                info)  color="$GREEN" ;;
                warn)  color="$YELLOW" ;;
                error|fatal) color="$RED" ;;
            esac

            local time_part="${ts:11:8}"
            local line="${time_part} ${color}${lvl}${NC} [${comp}] ${msg}"
            [ -n "$sess" ] && line="$line ${DIM}(${sess:0:12}...)${NC}"
            [ -n "$err" ] && line="$line\n  ${RED}Error: $err${NC}"

            echo -e "$line"
        done
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        local count=$(echo "$result" | wc -l | tr -d ' ')
        echo -e "${DIM}Showing $count logs (limit: $limit)${NC}"
    fi
}

#=============================================================================
# SECTION 6: COMMANDS
# Each cmd_* function implements one CLI command
#=============================================================================

cmd_dev() {
    require_project_dir
    cd "$PROJECT_DIR"

    # Parse flags
    local do_build=false
    local do_test=false
    local do_tail=false
    local do_kill=false
    local do_restart=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -b|--build)   do_build=true; do_test=true; shift ;;
            -t|--tail)    do_tail=true; shift ;;
            -k|--kill)    do_kill=true; shift ;;
            -r|--restart) do_restart=true; do_build=true; shift ;;
            -bt|-tb)      do_build=true; do_test=true; do_tail=true; shift ;;
            -rt|-tr)      do_restart=true; do_build=true; do_test=true; shift ;;
            -h|--help)
                echo ""
                echo -e "${CYAN}tron dev${NC} - Start beta development server"
                echo ""
                echo "Usage: tron dev [options]"
                echo ""
                echo "Options:"
                echo "  -b, --build     Build and test before starting"
                echo "  -t, --tail      Run in foreground (tail logs)"
                echo "  -k, --kill      Kill running beta server"
                echo "  -r, --restart   Kill, build, and restart beta server"
                echo ""
                echo "Examples:"
                echo "  tron dev       # Start server in background"
                echo "  tron dev -t    # Start server in foreground"
                echo "  tron dev -b    # Build, test, then start in background"
                echo "  tron dev -bt   # Build, test, then start in foreground"
                echo "  tron dev -k    # Kill running beta server"
                echo "  tron dev -r    # Kill, rebuild, restart (no tests)"
                echo "  tron dev -rt   # Kill, rebuild, test, restart"
                echo ""
                return 0
                ;;
            *) shift ;;
        esac
    done

    # Kill mode - just kill and exit
    if [ "$do_kill" = true ]; then
        beta_stop
        return 0
    fi

    # Restart mode - kill running server, then continue to build + start
    if [ "$do_restart" = true ]; then
        beta_stop 2>/dev/null || true
    fi

    # Check if beta port is already in use
    if beta_is_running; then
        print_error "Beta server already running on port $BETA_WS_PORT"
        echo "  Kill it: tron dev -k"
        exit 1
    fi

    # Optional build step
    if [ "$do_build" = true ]; then
        if [ "$do_test" = true ]; then
            print_header "Building and Testing"
        else
            print_header "Building"
        fi
        build_workspace

        if [ "$do_test" = true ]; then
            if ! run_tests; then
                print_warning "Tests failed!"
                if ! confirm_action "Continue anyway?"; then
                    exit 1
                fi
            fi
        fi
    fi

    # Ensure transcription sidecar is set up
    setup_transcription_sidecar

    # Ensure Playwright browser is available
    setup_browser

    if [ "$do_tail" = true ]; then
        # Foreground mode — exec replaces this process, so exports are needed
        export TRON_WS_PORT=$BETA_WS_PORT
        export TRON_HEALTH_PORT=$BETA_HEALTH_PORT
        export TRON_BUILD_TIER=beta
        export TRON_EVENT_STORE_DB="$TRON_HOME/database/beta.db"
        export TRON_REPO_ROOT="$PROJECT_DIR"
        export LOG_LEVEL="${LOG_LEVEL:-trace}"
        export NODE_ENV=development

        echo ""
        echo -e "${CYAN}Starting Beta Server (foreground)${NC}"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "  WebSocket: ws://localhost:$BETA_WS_PORT/ws"
        echo "  Health:    http://localhost:$BETA_HEALTH_PORT/health"
        echo ""
        echo -e "${YELLOW}Press Ctrl+C to stop${NC}"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        exec bun packages/agent/dist/interface/server.js
    else
        # Background mode — delegate to beta_start()
        beta_start
    fi
}

write_deployment_result() {
    local status="$1"
    local error_msg="${2:-null}"
    local commit
    local previous_commit

    commit=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
    previous_commit=$(cat "$DEPLOYED_COMMIT_FILE" 2>/dev/null || echo "unknown")

    if [ "$error_msg" = "null" ]; then
        error_msg="null"
    else
        error_msg="\"$error_msg\""
    fi

    cat > "$INSTALL_DIR/last-deployment.json" << RESULT
{
  "status": "$status",
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "commit": "$commit",
  "previousCommit": "$previous_commit",
  "error": $error_msg
}
RESULT
}

deploy_prepare() {
    require_project_dir
    cd "$PROJECT_DIR"

    if ! run_tests; then
        print_error "Tests failed"
        return 1
    fi

    build_production
    return $?
}

deploy_swap() {
    local delay="${1:-3}"

    require_project_dir
    require_installed
    cd "$PROJECT_DIR"

    # Write lock
    echo "$$" > "$DEPLOY_LOCK_FILE"

    # Cleanup trap: always release lock on exit
    trap 'rm -f "$DEPLOY_LOCK_FILE"' EXIT

    sleep "$delay"

    # Record previous commit
    local previous_commit
    previous_commit=$(cat "$DEPLOYED_COMMIT_FILE" 2>/dev/null || echo "unknown")

    # Backup current installation
    if [ -d "$INSTALL_DIR" ] && [ "$(ls -A "$INSTALL_DIR" 2>/dev/null)" ]; then
        print_status "Backing up current installation..."
        rm -rf "$INSTALL_DIR.bak"
        cp -a "$INSTALL_DIR" "$INSTALL_DIR.bak"
        if [ $? -ne 0 ]; then
            write_deployment_result "failed" "Backup copy failed"
            return 1
        fi
    fi

    # Stop service
    print_status "Stopping service..."
    launchctl unload "$PLIST_PATH" 2>/dev/null || true
    sleep 1

    # Copy new files
    print_status "Installing new version..."
    rm -rf "$INSTALL_DIR"/*
    cp -r "$PROJECT_DIR/dist/prod/"* "$INSTALL_DIR/"

    # Record new commit
    local new_commit
    new_commit=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
    echo "$new_commit" > "$DEPLOYED_COMMIT_FILE"

    # Start service
    print_status "Starting service..."
    launchctl load "$PLIST_PATH"

    # Health check loop: 5 attempts, 3 seconds apart
    local healthy=false
    for i in 1 2 3 4 5; do
        sleep 3
        if curl -sf "http://localhost:$PROD_HEALTH_PORT/health" > /dev/null 2>&1; then
            healthy=true
            break
        fi
        print_warning "Health check attempt $i/5 failed..."
    done

    if $healthy; then
        print_success "Service healthy"
        write_deployment_result "success"
        rm -rf "$INSTALL_DIR.bak"
        return 0
    fi

    # Auto-rollback
    print_error "Health check failed after 5 attempts, rolling back..."
    launchctl unload "$PLIST_PATH" 2>/dev/null || true
    sleep 1

    if [ -d "$INSTALL_DIR.bak" ]; then
        rm -rf "$INSTALL_DIR"/*
        cp -r "$INSTALL_DIR.bak/"* "$INSTALL_DIR/"
        echo "$previous_commit" > "$DEPLOYED_COMMIT_FILE"
        launchctl load "$PLIST_PATH"
        write_deployment_result "rolled_back" "Health check failed after 5 attempts"
        rm -rf "$INSTALL_DIR.bak"
        print_warning "Rolled back to previous version"
    else
        write_deployment_result "failed" "Health check failed and no backup available"
        print_error "No backup available for rollback"
    fi

    return 1
}

cmd_deploy_beta() {
    require_project_dir
    cd "$PROJECT_DIR"

    print_header "Deploying to Beta"
    echo "  Workspace: $PROJECT_DIR"
    echo ""

    local commit=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
    echo "  Commit: ${commit:0:7}"
    echo ""

    build_workspace

    if ! run_tests; then
        print_warning "Tests failed!"
        if ! confirm_action "Continue anyway?"; then
            exit 1
        fi
    fi

    if beta_is_running; then
        beta_stop
        sleep 1
    fi

    beta_start

    # Verify beta health before marking as verified
    print_status "Verifying beta health..."
    local healthy=false
    for i in 1 2 3 4 5; do
        sleep 2
        if health_check $BETA_HEALTH_PORT; then
            healthy=true
            break
        fi
        print_warning "Health check attempt $i/5..."
    done

    if $healthy; then
        # Write verification marker — required before prod deploy
        cat > "$BETA_VERIFIED_FILE" << MARKER
{"commit":"$commit","commitShort":"${commit:0:7}","timestamp":"$(date -u +%Y-%m-%dT%H:%M:%SZ)"}
MARKER
        echo ""
        print_success "Beta deploy verified on commit ${commit:0:7}"
        echo ""
    else
        rm -f "$BETA_VERIFIED_FILE"
        echo ""
        print_error "Beta health check failed — not verified"
        echo "  Prod deploy will be blocked until beta passes."
        echo ""
        return 1
    fi
}

cmd_deploy() {
    local prepare_only=false
    local swap_only=false
    local delay=3
    local tier="prod"
    local force=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --prepare) prepare_only=true; shift ;;
            --swap)    swap_only=true; shift ;;
            --delay)   delay="$2"; shift 2 ;;
            --force)   force=true; shift ;;
            beta)      tier="beta"; shift ;;
            *)         shift ;;
        esac
    done

    # Block all deploys from beta agent sessions
    if [ "$TRON_BUILD_TIER" = "beta" ]; then
        print_error "Deploy is disabled from beta sessions."
        echo "  Deploys must be initiated from the production server."
        echo "  Connect to prod (ws://localhost:$PROD_WS_PORT/ws) and deploy from there."
        return 1
    fi

    if [ "$tier" = "beta" ]; then
        cmd_deploy_beta
        return $?
    fi

    # Prod deploy — require beta verification on same commit (unless --force)
    if ! $swap_only; then
        local current_commit=$(git rev-parse HEAD 2>/dev/null || echo "unknown")

        if ! $force; then
            if [ ! -f "$BETA_VERIFIED_FILE" ]; then
                print_error "No beta verification found."
                echo "  Deploy to beta first:  tron deploy beta"
                echo "  Skip check:            tron deploy --force"
                return 1
            fi

            local verified_commit=$(cat "$BETA_VERIFIED_FILE" | grep -o '"commit":"[^"]*"' | cut -d'"' -f4)
            if [ "$verified_commit" != "$current_commit" ]; then
                local verified_short=$(cat "$BETA_VERIFIED_FILE" | grep -o '"commitShort":"[^"]*"' | cut -d'"' -f4)
                print_error "Beta was verified on a different commit."
                echo "  Current HEAD:     ${current_commit:0:7}"
                echo "  Beta verified on: $verified_short"
                echo ""
                echo "  Deploy to beta first:  tron deploy beta"
                echo "  Skip check:            tron deploy --force"
                return 1
            fi

            print_success "Beta verified on commit ${current_commit:0:7}"
        else
            print_warning "Skipping beta verification (--force)"
        fi
    fi

    if $prepare_only; then
        deploy_prepare
        return $?
    fi

    if $swap_only; then
        deploy_swap "$delay"
        return $?
    fi

    # Interactive deploy (existing flow)
    require_project_dir
    require_installed
    cd "$PROJECT_DIR"

    print_header "Deploying to Production"
    echo "  Workspace: $PROJECT_DIR"
    echo ""

    # Check for uncommitted changes
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        print_warning "You have uncommitted changes!"
        echo ""
        git status --short
        echo ""
        if ! confirm_action "Deploy anyway?"; then
            print_error "Aborted. Commit your changes first."
            exit 1
        fi
    fi

    # Run tests + build
    if ! deploy_prepare; then
        echo ""
        if ! confirm_action "Continue deployment anyway?"; then
            print_error "Deployment cancelled."
            exit 1
        fi
        print_warning "Continuing deployment despite failure..."
        build_production
    fi

    # Swap with 0 delay (interactive = immediate)
    deploy_swap 0

    echo ""
    print_success "Deploy complete!"
    echo ""
}

cmd_install() {
    require_project_dir
    cd "$PROJECT_DIR"

    print_header "Installing Tron Service"
    echo "  Workspace: $PROJECT_DIR"
    echo ""

    # Ensure directories exist
    mkdir -p "$BIN_DIR"
    mkdir -p "$TRON_HOME"
    mkdir -p "$INSTALL_DIR"
    mkdir -p "$HOME/Library/LaunchAgents"

    # Build production bundle
    if [ ! -f "$PROJECT_DIR/dist/prod/interface/server.js" ]; then
        build_production
    fi

    # Copy production bundle
    print_status "Installing to $INSTALL_DIR..."
    rm -rf "$INSTALL_DIR"/*
    cp -r "$PROJECT_DIR/dist/prod/"* "$INSTALL_DIR/"
    print_success "Installed to: $INSTALL_DIR"

    # Create launchd plist
    print_status "Creating launchd service..."
    create_launchd_plist
    print_success "Created: $PLIST_PATH"

    # Install CLI symlink
    print_status "Installing tron CLI..."
    ln -sf "$SCRIPT_DIR/tron" "$BIN_DIR/tron"
    print_success "Installed: $BIN_DIR/tron -> $SCRIPT_DIR/tron"

    # Check PATH
    if [[ ":$PATH:" != *":$BIN_DIR:"* ]]; then
        print_warning "Add to your shell profile: export PATH=\"\$HOME/.local/bin:\$PATH\""
    fi

    # Record initial deploy
    local current_commit=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
    echo "$current_commit" > "$DEPLOYED_COMMIT_FILE"

    # Start service
    print_status "Starting service..."
    launchctl load "$PLIST_PATH"
    sleep 3

    if service_is_running; then
        local pid=$(get_service_pid)
        print_success "Service started! (PID: ${pid:-unknown})"
    else
        print_error "Service failed to start. Check: tron errors"
    fi

    echo ""
    print_success "Installation complete!"
    echo ""
    echo "Locations:"
    echo "  App:   $INSTALL_DIR"
    echo "  Data:  $TRON_HOME"
    echo ""
    echo "Commands:"
    echo "  tron status   - Check service status"
    echo "  tron logs     - Query logs from database"
    echo "  tron dev      - Run beta server"
    echo "  tron deploy   - Deploy to production"
    echo ""
}

cmd_rollback() {
    local skip_confirm=false
    local delay=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --yes)   skip_confirm=true; shift ;;
            --delay) delay="$2"; shift 2 ;;
            *)       shift ;;
        esac
    done

    require_project_dir
    cd "$PROJECT_DIR"

    print_header "Rolling Back to Last Deployed State"

    if [ ! -d "$INSTALL_DIR.bak" ]; then
        print_error "No backup found. Cannot rollback."
        echo "  A backup is only available immediately after a deploy."
        exit 1
    fi

    if ! $skip_confirm; then
        if ! confirm_action "Restore previous deployment from backup?"; then
            print_error "Aborted."
            exit 1
        fi
    fi

    if [ "$delay" -gt 0 ]; then
        sleep "$delay"
    fi

    local previous_commit
    previous_commit=$(cat "$DEPLOYED_COMMIT_FILE" 2>/dev/null || echo "unknown")

    # Stop service
    print_status "Stopping service..."
    launchctl unload "$PLIST_PATH" 2>/dev/null || true
    sleep 1

    # Restore backup
    print_status "Restoring backup..."
    rm -rf "$INSTALL_DIR"/*
    cp -r "$INSTALL_DIR.bak/"* "$INSTALL_DIR/"

    # Start service
    launchctl load "$PLIST_PATH"
    sleep 3

    if service_is_running; then
        print_success "Production service restarted from backup"
    else
        print_error "Failed to restart service after rollback"
    fi

    write_deployment_result "rolled_back" "Manual rollback"
    rm -rf "$INSTALL_DIR.bak"

    echo ""
    print_success "Rollback complete!"
    echo ""
}

cmd_setup() {
    echo ""
    echo -e "${BLUE}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║                      Tron Agent Setup                         ║${NC}"
    echo -e "${BLUE}╚═══════════════════════════════════════════════════════════════╝${NC}"
    echo ""

    # Parse arguments
    local dev_mode=false
    while [[ $# -gt 0 ]]; do
        case $1 in
            --dev) dev_mode=true; shift ;;
            -h|--help)
                echo "Usage: tron setup [--dev]"
                echo ""
                echo "Options:"
                echo "  --dev    Also run tests after setup"
                exit 0
                ;;
            *) shift ;;
        esac
    done

    # Check prerequisites
    print_status "Checking prerequisites..."

    if ! command -v node &> /dev/null; then
        print_error "Node.js is not installed. Please install Node.js 20+ first."
        exit 1
    fi

    local node_version=$(node -v | cut -d'v' -f2 | cut -d'.' -f1)
    if [ "$node_version" -lt 20 ]; then
        print_error "Node.js version 20+ is required. Current: $(node -v)"
        exit 1
    fi
    print_success "Node.js $(node -v) found"

    if ! command -v bun &> /dev/null; then
        print_status "Installing Bun..."
        curl -fsSL https://bun.sh/install | bash
        export PATH="$HOME/.bun/bin:$PATH"
        print_success "Bun installed"
    else
        print_success "Bun $(bun --version) found"
    fi

    command -v git &> /dev/null && print_success "git $(git --version | cut -d' ' -f3) found"

    # Create directory structure
    print_status "Creating directory structure..."
    ensure_tron_home
    print_success "Created $TRON_HOME directory structure"

    # Create default config files
    print_status "Creating configuration files..."

    if [ ! -f "$TRON_HOME/settings.json" ]; then
        cat > "$TRON_HOME/settings.json" << 'EOF'
{
  "defaultModel": "claude-sonnet-4-20250514",
  "serverPort": 3847,
  "logging": { "level": "info", "maxFiles": 10, "maxSize": "10M" },
  "session": { "idleTimeout": 3600000, "autoSave": true, "autoSaveInterval": 30000 },
  "memory": { "ledgerAutoSave": true, "handoffOnCompact": true, "retentionDays": 90 },
  "hooks": { "timeout": 30000, "enabled": true }
}
EOF
        print_success "Created settings.json"
    else
        print_warning "settings.json already exists, skipping"
    fi


    if [ ! -f "$TRON_HOME/auth.json" ]; then
        cat > "$TRON_HOME/auth.json" << 'EOF'
{
  "version": 1,
  "providers": {},
  "lastUpdated": ""
}
EOF
        chmod 600 "$TRON_HOME/auth.json"
        print_success "Created auth.json"
    else
        print_warning "auth.json already exists, skipping"
    fi

    # Install dependencies
    print_status "Installing dependencies..."
    cd "$PROJECT_DIR"
    bun install
    print_success "Dependencies installed"

    # Build project
    build_workspace

    # Set up transcription sidecar
    setup_transcription_sidecar

    # Set up Playwright browser
    setup_browser

    # Run tests if dev mode
    if [ "$dev_mode" = true ]; then
        run_tests || print_warning "Some tests failed (continuing anyway)"
    fi

    # Create symlink for global 'tron' command
    print_status "Setting up tron command..."
    mkdir -p "$HOME/.local/bin"
    ln -sf "$PROJECT_DIR/scripts/tron" "$HOME/.local/bin/tron"
    print_success "Created symlink: ~/.local/bin/tron"

    # Check if ~/.local/bin is in PATH
    if [[ ":$PATH:" != *":$HOME/.local/bin:"* ]]; then
        print_warning "~/.local/bin is not in your PATH"
        echo "  Add this to your shell config (~/.zshrc or ~/.bashrc):"
        echo "    export PATH=\"\$HOME/.local/bin:\$PATH\""
        echo ""
    fi

    echo ""
    echo -e "${GREEN}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${GREEN}                    Tron Setup Complete!${NC}"
    echo -e "${GREEN}═══════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo "  Data directory: $TRON_HOME"
    echo "  Project path:   $PROJECT_DIR"
    echo ""
    echo -e "${YELLOW}Manual Setup Required${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    echo "  1. Copy auth.json from existing machine:"
    echo "     scp user@other-machine:~/.tron/auth.json ~/.tron/"
    echo ""
    echo "  2. Copy APNS credentials (for iOS push notifications):"
    echo "     scp -r user@other-machine:~/.tron/mods/apns/* ~/.tron/mods/apns/"
    echo ""
    echo "  3. Create Obsidian vault symlink (optional):"
    echo "     ln -s /path/to/your/obsidian/vault ~/.tron/obsidian"
    echo ""
    echo "  4. Configure API keys (if not using auth.json):"
    echo "     export ANTHROPIC_API_KEY=\"your-key-here\""
    echo ""
    echo "  5. Start development server:"
    echo "     tron dev"
    echo ""
    echo "  6. (Optional) Install as production service:"
    echo "     tron install"
    echo ""
}

cmd_status() {
    echo ""
    echo -e "${CYAN}Tron Service Status${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    # Production status
    if service_is_running; then
        local pid=$(get_service_pid)
        print_success "Production: ${GREEN}RUNNING${NC} (PID: ${pid:-unknown})"
        echo "  WebSocket: ws://localhost:$PROD_WS_PORT/ws"
        echo "  Health:    http://localhost:$PROD_HEALTH_PORT/health"

        if [ -n "$pid" ] && [ "$pid" != "-" ]; then
            local uptime=$(ps -o etime= -p "$pid" 2>/dev/null | tr -d ' ')
            [ -n "$uptime" ] && echo "  Uptime:    $uptime"
        fi

        if health_check $PROD_HEALTH_PORT; then
            echo -e "  Status:    ${GREEN}Healthy${NC}"
        else
            echo -e "  Status:    ${YELLOW}Not responding${NC}"
        fi

        if [ -f "$DEPLOYED_COMMIT_FILE" ]; then
            local deployed_commit=$(cat "$DEPLOYED_COMMIT_FILE")
            local commit_msg=$(cd "$PROJECT_DIR" 2>/dev/null && git log -1 --format="%s" "$deployed_commit" 2>/dev/null | head -c 50)
            echo "  Deployed:  ${deployed_commit:0:7} - $commit_msg"
        fi

        [ -d "$INSTALL_DIR" ] && echo "  Install:   $INSTALL_DIR"
    else
        print_warning "Production: ${YELLOW}STOPPED${NC}"
        [ -f "$DEPLOYED_COMMIT_FILE" ] && echo "  Last deployed: $(cat "$DEPLOYED_COMMIT_FILE" | head -c 7)"
        [ -d "$INSTALL_DIR" ] && echo "  Install:   $INSTALL_DIR"
    fi

    echo ""

    # Beta status
    local beta_pid=$(get_beta_pid)
    if [ -n "$beta_pid" ]; then
        print_success "Beta: ${GREEN}RUNNING${NC} (PID: $beta_pid)"
        echo "  WebSocket: ws://localhost:$BETA_WS_PORT/ws"
        echo "  Health:    http://localhost:$BETA_HEALTH_PORT/health"
        if health_check $BETA_HEALTH_PORT; then
            echo -e "  Status:    ${GREEN}Healthy${NC}"
        else
            echo -e "  Status:    ${YELLOW}Not responding${NC}"
        fi
    else
        echo "  Beta: not running"
    fi

    echo ""
    echo -e "${DIM}Logs:${NC}"
    echo -e "  ${DIM}Query: tron logs [-l level] [-q search] [-s session]${NC}"
    [ -f "$PROD_LOG_FILE" ] && echo -e "  ${DIM}File:  $PROD_LOG_FILE${NC}"
    echo ""
}

cmd_start() {
    local tier="${1:-prod}"
    if [ "$tier" = "beta" ]; then
        beta_start
        return $?
    fi
    if service_is_running; then
        print_warning "Production service is already running"
        return 0
    fi
    service_start
}

cmd_stop() {
    local tier="${1:-prod}"
    if [ "$tier" = "beta" ]; then
        beta_stop
        return $?
    fi
    service_stop
}

cmd_restart() {
    local tier="${1:-prod}"
    if [ "$tier" = "beta" ]; then
        print_status "Restarting beta service..."
        beta_stop 2>/dev/null || true
        sleep 1
        beta_start
        return $?
    fi
    print_status "Restarting production service..."
    service_stop 2>/dev/null || true
    sleep 1
    service_start
}

cmd_errors() {
    local tier="${1:-prod}"
    local db_path="$TRON_HOME/database/prod.db"
    [ "$tier" = "beta" ] && db_path="$TRON_HOME/database/beta.db"

    if [ -f "$db_path" ]; then
        echo -e "${RED}Recent errors from database:${NC}"
        sqlite3 -header -column "$db_path" \
            "SELECT datetime(timestamp/1000, 'unixepoch', 'localtime') as time, level, msg
             FROM logs
             WHERE level_num >= 50
             ORDER BY timestamp DESC
             LIMIT 20;" 2>/dev/null || echo "  No logs table found"
    fi

    if [ "$tier" = "prod" ] && [ -f "$PROD_LOG_FILE" ]; then
        echo ""
        echo -e "${RED}Recent errors from file log:${NC}"
        grep -i "error\|fatal\|exception" "$PROD_LOG_FILE" 2>/dev/null | tail -10 || echo "  No errors found"
    fi
}

cmd_uninstall() {
    print_header "Uninstalling Tron Service"

    if service_is_running; then
        print_status "Stopping service..."
        launchctl unload "$PLIST_PATH" 2>/dev/null || true
        sleep 1
    fi

    print_status "Removing launchd service..."
    rm -f "$PLIST_PATH"

    print_status "Removing CLI..."
    rm -f "$BIN_DIR/tron"

    print_status "Removing installed app..."
    rm -rf "$INSTALL_DIR"

    echo ""
    print_success "Service uninstalled"
    print_warning "Data preserved in: $TRON_HOME"
    echo ""
}

# =============================================================================
# Login Command
# OAuth PKCE login for Anthropic (Claude) accounts
# =============================================================================

AUTH_FILE="$TRON_HOME/auth.json"
OAUTH_CLIENT_ID="9d1c250a-e61b-44d9-88ed-5944d1962f5e"
OAUTH_AUTH_ENDPOINT="https://claude.ai/oauth/authorize"
OAUTH_TOKEN_ENDPOINT="https://console.anthropic.com/v1/oauth/token"
OAUTH_REDIRECT_URI="https://console.anthropic.com/oauth/code/callback"
OAUTH_SCOPES="org:create_api_key user:profile user:inference"

base64url_encode() {
    openssl base64 -A | tr '+/' '-_' | tr -d '='
}

cmd_login() {
    local label=""

    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --label) label="$2"; shift 2 ;;
            --status) cmd_login_status; return ;;
            -h|--help)
                echo ""
                echo "Usage: tron login [--label <name>] [--status]"
                echo ""
                echo "  --label <name>   Save as named account (for multi-account switching)"
                echo "  --status         Show current auth status"
                echo ""
                echo "Examples:"
                echo "  tron login                    Login with default (single) account"
                echo "  tron login --label Personal   Login and save as \"Personal\" account"
                echo "  tron login --label Work       Login and save as \"Work\" account"
                echo ""
                return ;;
            *) print_error "Unknown option: $1"; return 1 ;;
        esac
    done

    # Generate PKCE
    local code_verifier
    code_verifier=$(openssl rand 32 | base64url_encode)
    local code_challenge
    code_challenge=$(printf '%s' "$code_verifier" | openssl dgst -sha256 -binary | base64url_encode)

    # Build authorization URL
    local auth_url="${OAUTH_AUTH_ENDPOINT}?code=true&client_id=${OAUTH_CLIENT_ID}&response_type=code&redirect_uri=$(python3 -c "import urllib.parse; print(urllib.parse.quote('${OAUTH_REDIRECT_URI}'))")&scope=$(python3 -c "import urllib.parse; print(urllib.parse.quote('${OAUTH_SCOPES}'))")&code_challenge=${code_challenge}&code_challenge_method=S256&state=${code_verifier}"

    echo ""
    print_status "Opening browser for authentication..."
    if [[ -n "$label" ]]; then
        echo -e "  Account label: ${BOLD}${label}${NC}"
    fi
    echo ""
    echo "If browser doesn't open, visit:"
    echo "$auth_url"
    echo ""

    open "$auth_url"

    # Prompt for code
    printf "Paste the authorization code: "
    read -r auth_code
    echo ""

    if [[ -z "$auth_code" ]]; then
        print_error "No authorization code provided"
        return 1
    fi

    # Parse code#state
    local code="${auth_code%%#*}"
    local state="${auth_code#*#}"

    print_status "Exchanging authorization code..."

    # Exchange code for tokens
    local response
    response=$(curl -s -w "\n%{http_code}" -X POST "$OAUTH_TOKEN_ENDPOINT" \
        -H "Content-Type: application/json" \
        -d "{
            \"grant_type\": \"authorization_code\",
            \"client_id\": \"${OAUTH_CLIENT_ID}\",
            \"code\": \"${code}\",
            \"state\": \"${state}\",
            \"redirect_uri\": \"${OAUTH_REDIRECT_URI}\",
            \"code_verifier\": \"${code_verifier}\"
        }")

    local http_code
    http_code=$(echo "$response" | tail -1)
    local body
    body=$(echo "$response" | sed '$d')

    if [[ "$http_code" != "200" ]]; then
        print_error "Token exchange failed (HTTP $http_code): $body"
        return 1
    fi

    local access_token refresh_token expires_in expires_at
    access_token=$(echo "$body" | jq -r '.access_token')
    refresh_token=$(echo "$body" | jq -r '.refresh_token')
    expires_in=$(echo "$body" | jq -r '.expires_in')
    expires_at=$(( $(date +%s) * 1000 + expires_in * 1000 ))

    # Update auth.json
    if [[ ! -f "$AUTH_FILE" ]]; then
        echo '{"version":1,"providers":{}}' > "$AUTH_FILE"
        chmod 600 "$AUTH_FILE"
    fi

    local tmp_file="${AUTH_FILE}.tmp"

    if [[ -n "$label" ]]; then
        # Save as named account in accounts[] array
        jq --arg label "$label" \
           --arg at "$access_token" \
           --arg rt "$refresh_token" \
           --argjson ea "$expires_at" \
           '
           .providers.anthropic.accounts //= [] |
           (.providers.anthropic.accounts | map(.label) | index($label)) as $idx |
           if $idx != null then
               .providers.anthropic.accounts[$idx].oauth = {accessToken: $at, refreshToken: $rt, expiresAt: $ea}
           else
               .providers.anthropic.accounts += [{label: $label, oauth: {accessToken: $at, refreshToken: $rt, expiresAt: $ea}}]
           end |
           .lastUpdated = (now | todate)
           ' "$AUTH_FILE" > "$tmp_file" && mv "$tmp_file" "$AUTH_FILE"
        chmod 600 "$AUTH_FILE"

        print_success "Saved tokens for account \"${label}\""
    else
        # Save as legacy single oauth
        jq --arg at "$access_token" \
           --arg rt "$refresh_token" \
           --argjson ea "$expires_at" \
           '
           .providers.anthropic.oauth = {accessToken: $at, refreshToken: $rt, expiresAt: $ea} |
           .lastUpdated = (now | todate)
           ' "$AUTH_FILE" > "$tmp_file" && mv "$tmp_file" "$AUTH_FILE"
        chmod 600 "$AUTH_FILE"

        print_success "Saved OAuth tokens"
    fi

    local hours_left=$(( expires_in / 3600 ))
    echo -e "  ${DIM}Token expires in ~${hours_left}h${NC}"
    echo ""
}

cmd_login_status() {
    if [[ ! -f "$AUTH_FILE" ]]; then
        echo ""
        print_warning "No auth file found"
        echo ""
        return
    fi

    echo ""
    print_status "Anthropic auth status:"
    echo ""

    local now_ms=$(( $(date +%s) * 1000 ))

    # Named accounts
    local account_count
    account_count=$(jq -r '.providers.anthropic.accounts // [] | length' "$AUTH_FILE" 2>/dev/null)
    if [[ "$account_count" -gt 0 ]]; then
        jq -r --argjson now "$now_ms" '
            .providers.anthropic.accounts[] |
            .label as $l |
            .oauth.expiresAt as $e |
            .oauth.accessToken[0:20] as $t |
            if $e > $now then
                "  \(.label): \u001b[32mvalid\u001b[0m (~\(($e - $now) / 3600000 | floor)h)  \($t)..."
            else
                "  \(.label): \u001b[31mexpired\u001b[0m  \($t)..."
            end
        ' "$AUTH_FILE" 2>/dev/null | while IFS= read -r line; do echo -e "$line"; done
    fi

    # Legacy oauth
    local has_oauth
    has_oauth=$(jq -r '.providers.anthropic.oauth // empty | .accessToken' "$AUTH_FILE" 2>/dev/null)
    if [[ -n "$has_oauth" ]]; then
        local label="(default)"
        [[ "$account_count" -gt 0 ]] && label="(legacy)"
        jq -r --argjson now "$now_ms" --arg label "$label" '
            .providers.anthropic.oauth |
            .expiresAt as $e |
            .accessToken[0:20] as $t |
            if $e > $now then
                "  \($label): \u001b[32mvalid\u001b[0m (~\(($e - $now) / 3600000 | floor)h)  \($t)..."
            else
                "  \($label): \u001b[31mexpired\u001b[0m  \($t)..."
            end
        ' "$AUTH_FILE" 2>/dev/null | while IFS= read -r line; do echo -e "$line"; done
    fi

    echo ""
}

cmd_help() {
    echo ""
    echo -e "${CYAN}Tron - Persistent Coding Agent${NC}"
    echo ""
    echo "Usage: tron <command> [options]"
    echo ""
    echo "Development:"
    echo "  dev             Beta dev workflow (-b build, -t foreground, -k kill, -r restart)"
    echo "  setup           First-time project setup"
    echo ""
    echo -e "Service:                              ${DIM}prod (default)    beta${NC}"
    echo -e "  start [beta]    Start service       ${DIM}launchd           background process${NC}"
    echo "  stop [beta]     Stop service"
    echo "  restart [beta]  Restart service"
    echo "  status          Show all services"
    echo ""
    echo "Deployment:"
    echo -e "  deploy [beta]   Build, test, deploy  ${DIM}(prod: --prepare, --swap, --delay N)${NC}"
    echo "  install         Initial prod setup (launchd + CLI)"
    echo "  rollback        Restore previous prod deployment (--yes, --delay N)"
    echo "  uninstall       Remove prod service (preserves data)"
    echo ""
    echo "Auth:"
    echo "  login           Authenticate with Claude (--label <name> for multi-account)"
    echo ""
    echo "Logs:"
    echo "  logs [beta]     Query database logs (use -h for options)"
    echo "  errors [beta]   Show recent errors"
    echo ""
    echo "Dev workflows (use directly):"
    echo "  bun run build       Build all packages"
    echo "  bun run test        Run all tests"
    echo "  bun run lint        Lint source"
    echo "  bun run typecheck   Type check"
    echo ""
}

#=============================================================================
# SECTION 7: MAIN DISPATCH
# Parse arguments and route to appropriate command
#=============================================================================

ensure_tron_home

case "${1:-help}" in
    dev)       shift; cmd_dev "$@" ;;
    deploy)    shift; cmd_deploy "$@" ;;
    install)   cmd_install ;;
    rollback)  shift; cmd_rollback "$@" ;;
    setup)     shift; cmd_setup "$@" ;;
    status)    cmd_status ;;
    start)     shift; cmd_start "$@" ;;
    stop)      shift; cmd_stop "$@" ;;
    restart)   shift; cmd_restart "$@" ;;
    logs)      shift; query_logs "$@" ;;
    errors)    cmd_errors "${2:-}" ;;
    login)     shift; cmd_login "$@" ;;
    uninstall) cmd_uninstall ;;
    help|--help|-h)
        cmd_help
        ;;
    *)
        print_error "Unknown command: $1"
        cmd_help
        exit 1
        ;;
esac
