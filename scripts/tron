#!/bin/bash
# tron - CLI for Tron development and deployment
#
# Usage: tron <command> [options]
#
# Commands:
#   dev        Start server for development (-d for background)
#   ci         Run CI checks (fmt, clippy, test, doc)
#   deploy     Build, test, and deploy
#   install    Initial production setup (launchd + CLI)
#   rollback   Restore previous binary
#   setup      First-time project setup
#   status     Show service status and health
#   start/stop/restart  Manage launchd service
#   login      OAuth login for Claude (--label for multi-account)
#   logs       Query database logs
#   errors     Show recent errors
#   uninstall  Remove service (preserves data)
#   help       Show this help message

set -e

#=============================================================================
# SECTION 1: CONFIGURATION
#=============================================================================

# Resolve symlinks to get the real script location
SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SOURCE" ]; do
    DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"

# Data directories
TRON_HOME="${TRON_DATA_DIR:-$HOME/.tron}"
BIN_DIR="$HOME/.local/bin"

# Rust workspace
RUST_WORKSPACE="$PROJECT_DIR/packages/agent-rs"
RELEASE_BINARY="$RUST_WORKSPACE/target/release/tron"

# Installed binary
INSTALLED_BINARY="$TRON_HOME/tron"

# Service configuration
PLIST_NAME="com.tron.server"
PLIST_PATH="$HOME/Library/LaunchAgents/$PLIST_NAME.plist"
PROD_PORT=9847

# File paths
PROD_LOG_FILE="$TRON_HOME/artifacts/server.log"
DEPLOYED_COMMIT_FILE="$TRON_HOME/artifacts/deployed-commit"
DEPLOY_LOCK_FILE="$TRON_HOME/deploy.lock"

#=============================================================================
# SECTION 2: UTILITY FUNCTIONS
#=============================================================================

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

print_status()  { echo -e "${BLUE}▸${NC} $1"; }
print_success() { echo -e "${GREEN}✓${NC} $1"; }
print_error()   { echo -e "${RED}✗${NC} $1"; }
print_warning() { echo -e "${YELLOW}!${NC} $1"; }
print_header()  { echo -e "\n${CYAN}$1${NC}\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"; }

require_project_dir() {
    if [ ! -f "$RUST_WORKSPACE/Cargo.toml" ]; then
        print_error "Not in project directory: $PROJECT_DIR"
        exit 1
    fi
}

require_installed() {
    if [ ! -f "$PLIST_PATH" ]; then
        print_error "Tron not installed. Run: tron install"
        exit 1
    fi
}

confirm_action() {
    read -p "$1 (y/N) " -n 1 -r
    echo
    [[ $REPLY =~ ^[Yy]$ ]]
}

ensure_tron_home() {
    mkdir -p "$TRON_HOME"/{database,mods,notes,skills,artifacts/canvases}
    mkdir -p "$TRON_HOME"/mods/apns
}

#=============================================================================
# SECTION 3: BUILD FUNCTIONS
#=============================================================================

build_rust() {
    print_status "Building Rust workspace (release)..."
    (cd "$RUST_WORKSPACE" && cargo build --release) || { print_error "Build failed"; exit 1; }
    print_success "Build complete"
}

run_tests() {
    print_status "Running tests..."
    if (cd "$RUST_WORKSPACE" && cargo test --workspace 2>&1); then
        print_success "Tests passed"
        return 0
    else
        return 1
    fi
}

run_fmt_check() {
    print_status "Checking formatting..."
    (cd "$RUST_WORKSPACE" && cargo fmt --all -- --check) || { print_error "Format check failed (run: cargo fmt --all)"; return 1; }
    print_success "Formatting OK"
}

run_clippy() {
    print_status "Running clippy..."
    (cd "$RUST_WORKSPACE" && cargo clippy --workspace --all-targets -- -D warnings) || { print_error "Clippy failed"; return 1; }
    print_success "Clippy passed"
}

run_doc_check() {
    print_status "Building docs..."
    (cd "$RUST_WORKSPACE" && RUSTDOCFLAGS="-D warnings" cargo doc --workspace --no-deps) || { print_error "Doc build failed"; return 1; }
    print_success "Docs OK"
}

run_coverage() {
    if ! command -v cargo-tarpaulin &> /dev/null; then
        print_error "cargo-tarpaulin not installed. Install with: cargo install cargo-tarpaulin"
        return 1
    fi
    print_status "Running coverage..."
    (cd "$RUST_WORKSPACE" && cargo tarpaulin --workspace --out Html --output-dir target/coverage) || { print_error "Coverage failed"; return 1; }
    print_success "Coverage report: $RUST_WORKSPACE/target/coverage/tarpaulin-report.html"
}

#=============================================================================
# SECTION 4: SERVICE FUNCTIONS
#=============================================================================

service_is_running() {
    launchctl list 2>/dev/null | grep -q "$PLIST_NAME"
}

get_service_pid() {
    lsof -t -i :$PROD_PORT -sTCP:LISTEN 2>/dev/null || true
}

service_start() {
    if [ ! -f "$PLIST_PATH" ]; then
        print_error "Service not installed. Run: tron install"
        return 1
    fi

    print_status "Starting service..."
    launchctl load "$PLIST_PATH"
    sleep 2

    if service_is_running; then
        local pid=$(get_service_pid)
        print_success "Service started (PID: ${pid:-unknown})"
        echo "  Server: http://localhost:$PROD_PORT"
        echo "  Health: http://localhost:$PROD_PORT/health"
    else
        print_error "Failed to start service. Check: tron errors"
        return 1
    fi
}

service_stop() {
    if ! service_is_running; then
        print_warning "Service is not running"
        return 0
    fi

    print_status "Stopping service..."
    launchctl unload "$PLIST_PATH"
    sleep 1

    if ! service_is_running; then
        print_success "Service stopped"
    else
        print_error "Failed to stop service"
        return 1
    fi
}

health_check() {
    local response
    response=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:$PROD_PORT/health" 2>/dev/null || echo "000")
    [ "$response" = "200" ]
}

create_launchd_plist() {
    cat > "$PLIST_PATH" << PLIST
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>$PLIST_NAME</string>

    <key>ProgramArguments</key>
    <array>
        <string>$INSTALLED_BINARY</string>
        <string>--port</string>
        <string>$PROD_PORT</string>
    </array>

    <key>RunAtLoad</key>
    <true/>

    <key>KeepAlive</key>
    <dict>
        <key>SuccessfulExit</key>
        <false/>
        <key>Crashed</key>
        <true/>
    </dict>

    <key>ThrottleInterval</key>
    <integer>10</integer>

    <key>EnvironmentVariables</key>
    <dict>
        <key>HOME</key>
        <string>$HOME</string>
        <key>TRON_DATA_DIR</key>
        <string>$TRON_HOME</string>
        <key>RUST_LOG</key>
        <string>info</string>
    </dict>

    <key>StandardOutPath</key>
    <string>$PROD_LOG_FILE</string>

    <key>StandardErrorPath</key>
    <string>$PROD_LOG_FILE</string>

    <key>SoftResourceLimits</key>
    <dict>
        <key>NumberOfFiles</key>
        <integer>4096</integer>
    </dict>
</dict>
</plist>
PLIST
}

#=============================================================================
# SECTION 5: LOG FUNCTIONS
#=============================================================================

query_logs() {
    local level=""
    local output=""
    local limit=50
    local tail_mode=false
    local session=""
    local search=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -l|--level)   level="$2"; shift 2 ;;
            -o|--output)  output="$2"; shift 2 ;;
            -n|--limit)   limit="$2"; shift 2 ;;
            -t|--tail)    tail_mode=true; shift ;;
            -s|--session) session="$2"; shift 2 ;;
            -q|--search)  search="$2"; shift 2 ;;
            -h|--help)
                echo ""
                echo -e "${CYAN}tron logs${NC} - Query database logs"
                echo ""
                echo "Usage: tron logs [options]"
                echo ""
                echo "Options:"
                echo "  -l, --level LEVEL    Filter by level (trace/debug/info/warn/error)"
                echo "  -n, --limit N        Number of logs to show (default: 50)"
                echo "  -o, --output FILE    Write output to file"
                echo "  -s, --session ID     Filter by session ID"
                echo "  -q, --search TEXT    Search log messages"
                echo "  -t, --tail           Tail file logs instead of querying database"
                echo ""
                return 0
                ;;
            *) shift ;;
        esac
    done

    # Tail mode
    if [ "$tail_mode" = true ]; then
        if [ ! -f "$PROD_LOG_FILE" ]; then
            print_error "Log file not found: $PROD_LOG_FILE"
            return 1
        fi
        echo -e "${BLUE}Tailing log${NC}"
        echo -e "${DIM}$PROD_LOG_FILE${NC}"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        tail -f "$PROD_LOG_FILE"
        return 0
    fi

    # Database mode
    local db_path="$TRON_HOME/database/prod.db"

    if [ ! -f "$db_path" ]; then
        print_error "Database not found: $db_path"
        echo "The server may not have been started yet."
        return 1
    fi

    local table_exists
    table_exists=$(sqlite3 "$db_path" "SELECT name FROM sqlite_master WHERE type='table' AND name='logs';" 2>/dev/null)
    if [ -z "$table_exists" ]; then
        print_error "Logs table not found in database"
        return 1
    fi

    # Build SQL query
    local conditions=()

    if [ -n "$level" ]; then
        local level_num
        case "$level" in
            trace) level_num=10 ;;
            debug) level_num=20 ;;
            info)  level_num=30 ;;
            warn)  level_num=40 ;;
            error) level_num=50 ;;
            *)
                print_error "Invalid level: $level (valid: trace/debug/info/warn/error)"
                return 1
                ;;
        esac
        conditions+=("level_num >= $level_num")
    fi

    [ -n "$session" ] && conditions+=("session_id LIKE '%$session%'")

    local where_clause=""
    if [ ${#conditions[@]} -gt 0 ]; then
        where_clause="WHERE $(IFS=' AND '; echo "${conditions[*]}")"
    fi

    local sql
    if [ -n "$search" ]; then
        sql="SELECT l.timestamp, l.level, l.component, l.message, l.session_id, l.error_message
             FROM logs l
             JOIN logs_fts f ON l.id = f.log_id
             WHERE logs_fts MATCH '${search//\'/\'\'}'
             ${where_clause:+AND ${where_clause#WHERE }}
             ORDER BY l.timestamp DESC
             LIMIT $limit"
    else
        sql="SELECT timestamp, level, component, message, session_id, error_message
             FROM logs
             $where_clause
             ORDER BY timestamp DESC
             LIMIT $limit"
    fi

    local result
    result=$(sqlite3 -separator '|' "$db_path" "$sql" 2>&1)

    if [ $? -ne 0 ]; then
        print_error "Database query failed: $result"
        return 1
    fi

    if [ -z "$result" ]; then
        echo -e "${DIM}No logs found matching criteria${NC}"
        return 0
    fi

    if [ -n "$output" ]; then
        echo "$result" | while IFS='|' read -r ts lvl comp msg sess err; do
            local line="${ts} ${lvl} [${comp}] ${msg}"
            [ -n "$sess" ] && line="$line (${sess})"
            [ -n "$err" ] && line="$line | Error: $err"
            echo "$line"
        done > "$output"
        print_success "Wrote $(wc -l < "$output" | tr -d ' ') logs to $output"
    else
        echo -e "${CYAN}Database Logs${NC}"
        echo -e "${DIM}Database: $db_path${NC}"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "$result" | while IFS='|' read -r ts lvl comp msg sess err; do
            local color=""
            case "$lvl" in
                TRACE|DEBUG|trace|debug) color="$DIM" ;;
                INFO|info)  color="$GREEN" ;;
                WARN|warn)  color="$YELLOW" ;;
                ERROR|error) color="$RED" ;;
            esac

            local time_part="${ts:11:8}"
            local line="${time_part} ${color}${lvl}${NC} [${comp}] ${msg}"
            [ -n "$sess" ] && line="$line ${DIM}(${sess:0:12}...)${NC}"
            [ -n "$err" ] && line="$line\n  ${RED}Error: $err${NC}"

            echo -e "$line"
        done
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        local count=$(echo "$result" | wc -l | tr -d ' ')
        echo -e "${DIM}Showing $count logs (limit: $limit)${NC}"
    fi
}

#=============================================================================
# SECTION 6: COMMANDS
#=============================================================================

DEV_LOG_FILE="$TRON_HOME/artifacts/dev.log"
DEV_PID_FILE="$TRON_HOME/artifacts/dev.pid"

cmd_dev() {
    require_project_dir

    local do_build=false
    local do_test=false
    local daemon=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -b|--build)   do_build=true; shift ;;
            -t|--test)    do_test=true; shift ;;
            -bt|-tb)      do_build=true; do_test=true; shift ;;
            -d|--daemon)  daemon=true; shift ;;
            --stop)       dev_stop; return ;;
            --log|--logs) dev_tail_log; return ;;
            -h|--help)
                echo ""
                echo -e "${CYAN}tron dev${NC} - Start server for development"
                echo ""
                echo "Usage: tron dev [options]"
                echo ""
                echo "Options:"
                echo "  -b, --build     Build before starting"
                echo "  -t, --test      Run tests before starting"
                echo "  -d, --daemon    Run in background (log to $DEV_LOG_FILE)"
                echo "  --stop          Stop background dev server"
                echo "  --log           Tail the dev log"
                echo ""
                echo "Examples:"
                echo "  tron dev          # Foreground, last build"
                echo "  tron dev -b       # Build then foreground"
                echo "  tron dev -bd      # Build then background"
                echo "  tron dev -bt      # Build, test, then foreground"
                echo "  tron dev --stop   # Stop background server"
                echo ""
                return 0
                ;;
            -bd|-db)      do_build=true; daemon=true; shift ;;
            -btd|-bdt|-tbd|-tdb|-dbt|-dtb) do_build=true; do_test=true; daemon=true; shift ;;
            *) shift ;;
        esac
    done

    if [ "$do_build" = true ]; then
        build_rust
    fi

    if [ "$do_test" = true ]; then
        if ! run_tests; then
            print_warning "Tests failed!"
            if ! confirm_action "Continue anyway?"; then
                exit 1
            fi
        fi
    fi

    # Check if something is already listening on the port
    local existing_pid
    existing_pid=$(lsof -t -i :$PROD_PORT -sTCP:LISTEN 2>/dev/null || true)
    if [ -n "$existing_pid" ]; then
        print_error "Port $PROD_PORT already in use (PID: $existing_pid)"
        echo "  Stop it with: tron dev --stop  or  tron stop"
        return 1
    fi

    if [ "$daemon" = true ]; then
        dev_start_daemon
    else
        dev_start_foreground
    fi
}

dev_start_foreground() {
    if [ -f "$RELEASE_BINARY" ]; then
        echo ""
        echo -e "${CYAN}Starting Tron Server (foreground)${NC}"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "  Server: http://localhost:$PROD_PORT"
        echo "  Health: http://localhost:$PROD_PORT/health"
        echo ""
        echo -e "${YELLOW}Press Ctrl+C to stop${NC}"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        RUST_LOG="${RUST_LOG:-debug}" exec "$RELEASE_BINARY" --port "$PROD_PORT"
    else
        echo ""
        echo -e "${CYAN}Starting Tron Server via cargo run (foreground)${NC}"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "  Server: http://localhost:$PROD_PORT"
        echo ""
        echo -e "${YELLOW}Press Ctrl+C to stop${NC}"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        RUST_LOG="${RUST_LOG:-debug}" exec cargo run --release --manifest-path "$RUST_WORKSPACE/Cargo.toml" --bin tron -- --port "$PROD_PORT"
    fi
}

dev_start_daemon() {
    if [ ! -f "$RELEASE_BINARY" ]; then
        print_error "No release binary found. Build first: tron dev -bd"
        return 1
    fi

    mkdir -p "$(dirname "$DEV_LOG_FILE")"
    : > "$DEV_LOG_FILE"

    RUST_LOG="${RUST_LOG:-debug}" nohup "$RELEASE_BINARY" --port "$PROD_PORT" \
        >> "$DEV_LOG_FILE" 2>&1 &
    local pid=$!
    echo "$pid" > "$DEV_PID_FILE"

    # Wait briefly and verify it started
    sleep 2
    if kill -0 "$pid" 2>/dev/null; then
        echo ""
        print_success "Dev server running in background (PID: $pid)"
        echo "  Server: http://localhost:$PROD_PORT"
        echo "  Health: http://localhost:$PROD_PORT/health"
        echo "  Log:    $DEV_LOG_FILE"
        echo ""
        echo "  Stop with: tron dev --stop"
        echo "  Tail log:  tron dev --log"
        echo ""
    else
        print_error "Dev server failed to start. Check log:"
        echo "  $DEV_LOG_FILE"
        rm -f "$DEV_PID_FILE"
        return 1
    fi
}

dev_stop() {
    local pid

    # Try PID file first
    if [ -f "$DEV_PID_FILE" ]; then
        pid=$(cat "$DEV_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            print_status "Stopping dev server (PID: $pid)..."
            kill "$pid"
            sleep 1
            # Force kill if still running
            if kill -0 "$pid" 2>/dev/null; then
                kill -9 "$pid" 2>/dev/null || true
            fi
            rm -f "$DEV_PID_FILE"
            print_success "Dev server stopped"
            return 0
        fi
        rm -f "$DEV_PID_FILE"
    fi

    # Fall back to port lookup
    pid=$(lsof -t -i :$PROD_PORT -sTCP:LISTEN 2>/dev/null || true)
    if [ -n "$pid" ]; then
        print_status "Stopping process on port $PROD_PORT (PID: $pid)..."
        kill "$pid"
        sleep 1
        if kill -0 "$pid" 2>/dev/null; then
            kill -9 "$pid" 2>/dev/null || true
        fi
        rm -f "$DEV_PID_FILE"
        print_success "Stopped"
        return 0
    fi

    print_warning "No dev server running"
}

dev_tail_log() {
    if [ ! -f "$DEV_LOG_FILE" ]; then
        print_error "No dev log file found: $DEV_LOG_FILE"
        return 1
    fi
    echo -e "${BLUE}Tailing dev log${NC} ${DIM}($DEV_LOG_FILE)${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    tail -f "$DEV_LOG_FILE"
}

write_deployment_result() {
    local status="$1"
    local error_msg="${2:-null}"
    local commit
    local previous_commit

    commit=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
    previous_commit=$(cat "$DEPLOYED_COMMIT_FILE" 2>/dev/null || echo "unknown")

    if [ "$error_msg" = "null" ]; then
        error_msg="null"
    else
        error_msg="\"$error_msg\""
    fi

    cat > "$TRON_HOME/artifacts/last-deployment.json" << RESULT
{
  "status": "$status",
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "commit": "$commit",
  "previousCommit": "$previous_commit",
  "error": $error_msg
}
RESULT
}

cmd_deploy() {
    local force=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force) force=true; shift ;;
            *) shift ;;
        esac
    done

    require_project_dir
    require_installed
    cd "$RUST_WORKSPACE"

    print_header "Deploying to Production"
    echo "  Workspace: $PROJECT_DIR"
    echo ""

    # Check for uncommitted changes
    if ! git -C "$PROJECT_DIR" diff-index --quiet HEAD -- 2>/dev/null; then
        print_warning "You have uncommitted changes!"
        echo ""
        git -C "$PROJECT_DIR" status --short
        echo ""
        if ! $force && ! confirm_action "Deploy anyway?"; then
            print_error "Aborted. Commit your changes first."
            exit 1
        fi
    fi

    # Build and test
    build_rust

    if ! run_tests; then
        print_error "Tests failed"
        if ! $force && ! confirm_action "Continue deployment anyway?"; then
            print_error "Deployment cancelled."
            exit 1
        fi
        print_warning "Continuing deployment despite test failure..."
    fi

    # Write lock
    echo "$$" > "$DEPLOY_LOCK_FILE"
    trap 'rm -f "$DEPLOY_LOCK_FILE"' EXIT

    # Record previous commit
    local previous_commit
    previous_commit=$(cat "$DEPLOYED_COMMIT_FILE" 2>/dev/null || echo "unknown")

    # Backup current binary
    if [ -f "$INSTALLED_BINARY" ]; then
        print_status "Backing up current binary..."
        cp "$INSTALLED_BINARY" "${INSTALLED_BINARY}.bak"
    fi

    # Stop service
    print_status "Stopping service..."
    launchctl unload "$PLIST_PATH" 2>/dev/null || true
    sleep 1

    # Copy new binary
    print_status "Installing new binary..."
    cp "$RELEASE_BINARY" "$INSTALLED_BINARY"
    chmod +x "$INSTALLED_BINARY"

    # Record new commit
    local new_commit
    new_commit=$(git -C "$PROJECT_DIR" rev-parse HEAD 2>/dev/null || echo "unknown")
    echo "$new_commit" > "$DEPLOYED_COMMIT_FILE"

    # Start service
    print_status "Starting service..."
    launchctl load "$PLIST_PATH"

    # Health check loop
    local healthy=false
    for i in 1 2 3 4 5; do
        sleep 3
        if health_check; then
            healthy=true
            break
        fi
        print_warning "Health check attempt $i/5 failed..."
    done

    if $healthy; then
        print_success "Service healthy"
        write_deployment_result "success"
        rm -f "${INSTALLED_BINARY}.bak"
        echo ""
        print_success "Deploy complete!"
        echo ""
        return 0
    fi

    # Auto-rollback
    print_error "Health check failed after 5 attempts, rolling back..."
    launchctl unload "$PLIST_PATH" 2>/dev/null || true
    sleep 1

    if [ -f "${INSTALLED_BINARY}.bak" ]; then
        mv "${INSTALLED_BINARY}.bak" "$INSTALLED_BINARY"
        echo "$previous_commit" > "$DEPLOYED_COMMIT_FILE"
        launchctl load "$PLIST_PATH"
        write_deployment_result "rolled_back" "Health check failed after 5 attempts"
        print_warning "Rolled back to previous version"
    else
        write_deployment_result "failed" "Health check failed and no backup available"
        print_error "No backup available for rollback"
    fi

    return 1
}

cmd_install() {
    require_project_dir

    print_header "Installing Tron Service"
    echo "  Workspace: $PROJECT_DIR"
    echo ""

    # Ensure directories exist
    mkdir -p "$BIN_DIR"
    mkdir -p "$TRON_HOME/artifacts"
    mkdir -p "$HOME/Library/LaunchAgents"

    # Build if needed
    if [ ! -f "$RELEASE_BINARY" ]; then
        build_rust
    fi

    # Copy binary
    print_status "Installing binary to $INSTALLED_BINARY..."
    cp "$RELEASE_BINARY" "$INSTALLED_BINARY"
    chmod +x "$INSTALLED_BINARY"
    print_success "Installed binary"

    # Create launchd plist
    print_status "Creating launchd service..."
    create_launchd_plist
    print_success "Created: $PLIST_PATH"

    # Install CLI symlink
    print_status "Installing tron CLI..."
    ln -sf "$SCRIPT_DIR/tron" "$BIN_DIR/tron"
    print_success "Installed: $BIN_DIR/tron -> $SCRIPT_DIR/tron"

    # Check PATH
    if [[ ":$PATH:" != *":$BIN_DIR:"* ]]; then
        print_warning "Add to your shell profile: export PATH=\"\$HOME/.local/bin:\$PATH\""
    fi

    # Record initial deploy
    local current_commit=$(git -C "$PROJECT_DIR" rev-parse HEAD 2>/dev/null || echo "unknown")
    echo "$current_commit" > "$DEPLOYED_COMMIT_FILE"

    # Start service
    print_status "Starting service..."
    launchctl load "$PLIST_PATH"
    sleep 3

    if service_is_running; then
        local pid=$(get_service_pid)
        print_success "Service started! (PID: ${pid:-unknown})"
    else
        print_error "Service failed to start. Check: tron errors"
    fi

    echo ""
    print_success "Installation complete!"
    echo ""
    echo "Locations:"
    echo "  Binary: $INSTALLED_BINARY"
    echo "  Data:   $TRON_HOME"
    echo ""
    echo "Commands:"
    echo "  tron status   - Check service status"
    echo "  tron logs     - Query logs from database"
    echo "  tron dev      - Run server in foreground"
    echo "  tron deploy   - Deploy to production"
    echo ""
}

cmd_rollback() {
    local skip_confirm=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --yes) skip_confirm=true; shift ;;
            *)     shift ;;
        esac
    done

    print_header "Rolling Back to Previous Binary"

    if [ ! -f "${INSTALLED_BINARY}.bak" ]; then
        print_error "No backup found. Cannot rollback."
        echo "  A backup is only available immediately after a deploy."
        exit 1
    fi

    if ! $skip_confirm; then
        if ! confirm_action "Restore previous binary from backup?"; then
            print_error "Aborted."
            exit 1
        fi
    fi

    # Stop service
    print_status "Stopping service..."
    launchctl unload "$PLIST_PATH" 2>/dev/null || true
    sleep 1

    # Restore backup
    print_status "Restoring backup..."
    mv "${INSTALLED_BINARY}.bak" "$INSTALLED_BINARY"

    # Start service
    launchctl load "$PLIST_PATH"
    sleep 3

    if service_is_running; then
        print_success "Service restarted from backup"
    else
        print_error "Failed to restart service after rollback"
    fi

    write_deployment_result "rolled_back" "Manual rollback"

    echo ""
    print_success "Rollback complete!"
    echo ""
}

cmd_setup() {
    echo ""
    echo -e "${BLUE}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║                        Tron Setup                             ║${NC}"
    echo -e "${BLUE}╚═══════════════════════════════════════════════════════════════╝${NC}"
    echo ""

    local dev_mode=false
    while [[ $# -gt 0 ]]; do
        case $1 in
            --dev) dev_mode=true; shift ;;
            -h|--help)
                echo "Usage: tron setup [--dev]"
                echo ""
                echo "Options:"
                echo "  --dev    Also run tests after setup"
                exit 0
                ;;
            *) shift ;;
        esac
    done

    # Check prerequisites
    print_status "Checking prerequisites..."

    if ! command -v cargo &> /dev/null; then
        print_error "Rust is not installed. Install from https://rustup.rs"
        exit 1
    fi
    print_success "cargo $(cargo --version | cut -d' ' -f2) found"

    if ! command -v rustc &> /dev/null; then
        print_error "rustc not found."
        exit 1
    fi
    print_success "rustc $(rustc --version | cut -d' ' -f2) found"

    command -v git &> /dev/null && print_success "git $(git --version | cut -d' ' -f3) found"

    # Create directory structure
    print_status "Creating directory structure..."
    ensure_tron_home
    print_success "Created $TRON_HOME directory structure"

    # Create default config files
    print_status "Creating configuration files..."

    if [ ! -f "$TRON_HOME/settings.json" ]; then
        cat > "$TRON_HOME/settings.json" << 'EOF'
{
  "server": {
    "defaultModel": "claude-sonnet-4-20250514",
    "defaultProvider": "anthropic",
    "port": 9847,
    "maxConcurrentSessions": 10
  },
  "logging": {
    "dbLogLevel": "info"
  },
  "tools": {
    "bash": { "defaultTimeoutMs": 120000 },
    "read": { "defaultLimitLines": 2000 }
  }
}
EOF
        print_success "Created settings.json"
    else
        print_warning "settings.json already exists, skipping"
    fi

    if [ ! -f "$TRON_HOME/auth.json" ]; then
        cat > "$TRON_HOME/auth.json" << 'EOF'
{
  "version": 1,
  "providers": {},
  "lastUpdated": ""
}
EOF
        chmod 600 "$TRON_HOME/auth.json"
        print_success "Created auth.json"
    else
        print_warning "auth.json already exists, skipping"
    fi

    # Build
    build_rust

    if [ "$dev_mode" = true ]; then
        run_tests || print_warning "Some tests failed (continuing anyway)"
    fi

    # Create symlink for global 'tron' command
    print_status "Setting up tron command..."
    mkdir -p "$HOME/.local/bin"
    ln -sf "$PROJECT_DIR/scripts/tron" "$HOME/.local/bin/tron"
    print_success "Created symlink: ~/.local/bin/tron"

    if [[ ":$PATH:" != *":$HOME/.local/bin:"* ]]; then
        print_warning "~/.local/bin is not in your PATH"
        echo "  Add this to your shell config (~/.zshrc or ~/.bashrc):"
        echo "    export PATH=\"\$HOME/.local/bin:\$PATH\""
        echo ""
    fi

    echo ""
    echo -e "${GREEN}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${GREEN}                      Tron Setup Complete!${NC}"
    echo -e "${GREEN}═══════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo "  Data directory: $TRON_HOME"
    echo "  Project path:   $PROJECT_DIR"
    echo ""
    echo "  Next steps:"
    echo "    tron login       # Authenticate with Claude"
    echo "    tron dev         # Start server in foreground"
    echo "    tron install     # Install as launchd service"
    echo ""
}

cmd_status() {
    echo ""
    echo -e "${CYAN}Tron Service Status${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    if service_is_running; then
        local pid=$(get_service_pid)
        print_success "Service: ${GREEN}RUNNING${NC} (PID: ${pid:-unknown})"
        echo "  Server: http://localhost:$PROD_PORT"
        echo "  Health: http://localhost:$PROD_PORT/health"

        if [ -n "$pid" ] && [ "$pid" != "-" ]; then
            local uptime=$(ps -o etime= -p "$pid" 2>/dev/null | tr -d ' ')
            [ -n "$uptime" ] && echo "  Uptime: $uptime"
        fi

        if health_check; then
            echo -e "  Status: ${GREEN}Healthy${NC}"
        else
            echo -e "  Status: ${YELLOW}Not responding${NC}"
        fi

        if [ -f "$DEPLOYED_COMMIT_FILE" ]; then
            local deployed_commit=$(cat "$DEPLOYED_COMMIT_FILE")
            local commit_msg=$(cd "$PROJECT_DIR" 2>/dev/null && git log -1 --format="%s" "$deployed_commit" 2>/dev/null | head -c 50)
            echo "  Deployed: ${deployed_commit:0:7} - $commit_msg"
        fi

        [ -f "$INSTALLED_BINARY" ] && echo "  Binary: $INSTALLED_BINARY"
    else
        print_warning "Service: ${YELLOW}STOPPED${NC}"
        [ -f "$DEPLOYED_COMMIT_FILE" ] && echo "  Last deployed: $(cat "$DEPLOYED_COMMIT_FILE" | head -c 7)"
        [ -f "$INSTALLED_BINARY" ] && echo "  Binary: $INSTALLED_BINARY"
    fi

    echo ""
    echo -e "${DIM}Logs:${NC}"
    echo -e "  ${DIM}Query: tron logs [-l level] [-q search] [-s session]${NC}"
    [ -f "$PROD_LOG_FILE" ] && echo -e "  ${DIM}File:  $PROD_LOG_FILE${NC}"
    echo ""
}

cmd_start() {
    if service_is_running; then
        print_warning "Service is already running"
        return 0
    fi
    service_start
}

cmd_stop() {
    service_stop
}

cmd_restart() {
    print_status "Restarting service..."
    service_stop 2>/dev/null || true
    sleep 1
    service_start
}

cmd_errors() {
    local db_path="$TRON_HOME/database/prod.db"

    if [ -f "$db_path" ]; then
        echo -e "${RED}Recent errors from database:${NC}"
        sqlite3 -header -column "$db_path" \
            "SELECT timestamp as time, level, message
             FROM logs
             WHERE level_num >= 50
             ORDER BY timestamp DESC
             LIMIT 20;" 2>/dev/null || echo "  No logs table found"
    fi

    if [ -f "$PROD_LOG_FILE" ]; then
        echo ""
        echo -e "${RED}Recent errors from file log:${NC}"
        grep -i "error\|fatal\|exception" "$PROD_LOG_FILE" 2>/dev/null | tail -10 || echo "  No errors found"
    fi
}

cmd_uninstall() {
    print_header "Uninstalling Tron Service"

    if service_is_running; then
        print_status "Stopping service..."
        launchctl unload "$PLIST_PATH" 2>/dev/null || true
        sleep 1
    fi

    print_status "Removing launchd service..."
    rm -f "$PLIST_PATH"

    print_status "Removing CLI..."
    rm -f "$BIN_DIR/tron"

    print_status "Removing installed binary..."
    rm -f "$INSTALLED_BINARY" "${INSTALLED_BINARY}.bak"

    echo ""
    print_success "Service uninstalled"
    print_warning "Data preserved in: $TRON_HOME"
    echo ""
}

# =============================================================================
# Login Command (OAuth PKCE)
# =============================================================================

AUTH_FILE="$TRON_HOME/auth.json"
OAUTH_CLIENT_ID="9d1c250a-e61b-44d9-88ed-5944d1962f5e"
OAUTH_AUTH_ENDPOINT="https://claude.ai/oauth/authorize"
OAUTH_TOKEN_ENDPOINT="https://console.anthropic.com/v1/oauth/token"
OAUTH_REDIRECT_URI="https://console.anthropic.com/oauth/code/callback"
OAUTH_SCOPES="org:create_api_key user:profile user:inference"

base64url_encode() {
    openssl base64 -A | tr '+/' '-_' | tr -d '='
}

cmd_login() {
    local label=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --label) label="$2"; shift 2 ;;
            --status) cmd_login_status; return ;;
            -h|--help)
                echo ""
                echo "Usage: tron login [--label <name>] [--status]"
                echo ""
                echo "  --label <name>   Save as named account (for multi-account switching)"
                echo "  --status         Show current auth status"
                echo ""
                return ;;
            *) print_error "Unknown option: $1"; return 1 ;;
        esac
    done

    # Generate PKCE
    local code_verifier
    code_verifier=$(openssl rand 32 | base64url_encode)
    local code_challenge
    code_challenge=$(printf '%s' "$code_verifier" | openssl dgst -sha256 -binary | base64url_encode)

    local auth_url="${OAUTH_AUTH_ENDPOINT}?code=true&client_id=${OAUTH_CLIENT_ID}&response_type=code&redirect_uri=$(python3 -c "import urllib.parse; print(urllib.parse.quote('${OAUTH_REDIRECT_URI}'))")&scope=$(python3 -c "import urllib.parse; print(urllib.parse.quote('${OAUTH_SCOPES}'))")&code_challenge=${code_challenge}&code_challenge_method=S256&state=${code_verifier}"

    echo ""
    print_status "Opening browser for authentication..."
    if [[ -n "$label" ]]; then
        echo -e "  Account label: ${BOLD}${label}${NC}"
    fi
    echo ""
    echo "If browser doesn't open, visit:"
    echo "$auth_url"
    echo ""

    open "$auth_url"

    printf "Paste the authorization code: "
    read -r auth_code
    echo ""

    if [[ -z "$auth_code" ]]; then
        print_error "No authorization code provided"
        return 1
    fi

    local code="${auth_code%%#*}"
    local state="${auth_code#*#}"

    print_status "Exchanging authorization code..."

    local response
    response=$(curl -s -w "\n%{http_code}" -X POST "$OAUTH_TOKEN_ENDPOINT" \
        -H "Content-Type: application/json" \
        -d "{
            \"grant_type\": \"authorization_code\",
            \"client_id\": \"${OAUTH_CLIENT_ID}\",
            \"code\": \"${code}\",
            \"state\": \"${state}\",
            \"redirect_uri\": \"${OAUTH_REDIRECT_URI}\",
            \"code_verifier\": \"${code_verifier}\"
        }")

    local http_code
    http_code=$(echo "$response" | tail -1)
    local body
    body=$(echo "$response" | sed '$d')

    if [[ "$http_code" != "200" ]]; then
        print_error "Token exchange failed (HTTP $http_code): $body"
        return 1
    fi

    local access_token refresh_token expires_in expires_at
    access_token=$(echo "$body" | jq -r '.access_token')
    refresh_token=$(echo "$body" | jq -r '.refresh_token')
    expires_in=$(echo "$body" | jq -r '.expires_in')
    expires_at=$(( $(date +%s) * 1000 + expires_in * 1000 ))

    if [[ ! -f "$AUTH_FILE" ]]; then
        echo '{"version":1,"providers":{}}' > "$AUTH_FILE"
        chmod 600 "$AUTH_FILE"
    fi

    local tmp_file="${AUTH_FILE}.tmp"

    if [[ -n "$label" ]]; then
        jq --arg label "$label" \
           --arg at "$access_token" \
           --arg rt "$refresh_token" \
           --argjson ea "$expires_at" \
           '
           .providers.anthropic.accounts //= [] |
           (.providers.anthropic.accounts | map(.label) | index($label)) as $idx |
           if $idx != null then
               .providers.anthropic.accounts[$idx].oauth = {accessToken: $at, refreshToken: $rt, expiresAt: $ea}
           else
               .providers.anthropic.accounts += [{label: $label, oauth: {accessToken: $at, refreshToken: $rt, expiresAt: $ea}}]
           end |
           .lastUpdated = (now | todate)
           ' "$AUTH_FILE" > "$tmp_file" && mv "$tmp_file" "$AUTH_FILE"
        chmod 600 "$AUTH_FILE"

        print_success "Saved tokens for account \"${label}\""
    else
        jq --arg at "$access_token" \
           --arg rt "$refresh_token" \
           --argjson ea "$expires_at" \
           '
           .providers.anthropic.oauth = {accessToken: $at, refreshToken: $rt, expiresAt: $ea} |
           .lastUpdated = (now | todate)
           ' "$AUTH_FILE" > "$tmp_file" && mv "$tmp_file" "$AUTH_FILE"
        chmod 600 "$AUTH_FILE"

        print_success "Saved OAuth tokens"
    fi

    local hours_left=$(( expires_in / 3600 ))
    echo -e "  ${DIM}Token expires in ~${hours_left}h${NC}"
    echo ""
}

cmd_login_status() {
    if [[ ! -f "$AUTH_FILE" ]]; then
        echo ""
        print_warning "No auth file found"
        echo ""
        return
    fi

    echo ""
    print_status "Anthropic auth status:"
    echo ""

    local now_ms=$(( $(date +%s) * 1000 ))

    local account_count
    account_count=$(jq -r '.providers.anthropic.accounts // [] | length' "$AUTH_FILE" 2>/dev/null)
    if [[ "$account_count" -gt 0 ]]; then
        jq -r --argjson now "$now_ms" '
            .providers.anthropic.accounts[] |
            .label as $l |
            .oauth.expiresAt as $e |
            .oauth.accessToken[0:20] as $t |
            if $e > $now then
                "  \(.label): \u001b[32mvalid\u001b[0m (~\(($e - $now) / 3600000 | floor)h)  \($t)..."
            else
                "  \(.label): \u001b[31mexpired\u001b[0m  \($t)..."
            end
        ' "$AUTH_FILE" 2>/dev/null | while IFS= read -r line; do echo -e "$line"; done
    fi

    local has_oauth
    has_oauth=$(jq -r '.providers.anthropic.oauth // empty | .accessToken' "$AUTH_FILE" 2>/dev/null)
    if [[ -n "$has_oauth" ]]; then
        local label="(default)"
        [[ "$account_count" -gt 0 ]] && label="(legacy)"
        jq -r --argjson now "$now_ms" --arg label "$label" '
            .providers.anthropic.oauth |
            .expiresAt as $e |
            .accessToken[0:20] as $t |
            if $e > $now then
                "  \($label): \u001b[32mvalid\u001b[0m (~\(($e - $now) / 3600000 | floor)h)  \($t)..."
            else
                "  \($label): \u001b[31mexpired\u001b[0m  \($t)..."
            end
        ' "$AUTH_FILE" 2>/dev/null | while IFS= read -r line; do echo -e "$line"; done
    fi

    echo ""
}

cmd_ci() {
    require_project_dir

    local steps=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            fmt)      steps+=(fmt); shift ;;
            check)    steps+=(check); shift ;;
            clippy)   steps+=(clippy); shift ;;
            test)     steps+=(test); shift ;;
            doc)      steps+=(doc); shift ;;
            coverage) steps+=(coverage); shift ;;
            -h|--help)
                echo ""
                echo -e "${CYAN}tron ci${NC} - Run CI checks"
                echo ""
                echo "Usage: tron ci [steps...]"
                echo ""
                echo "Steps (run in order listed):"
                echo "  fmt        Check formatting (cargo fmt --check)"
                echo "  check      Compile check (cargo check --all-targets)"
                echo "  clippy     Lint with -D warnings"
                echo "  test       Run all tests"
                echo "  doc        Build docs with -D warnings"
                echo "  coverage   Generate coverage report (requires cargo-tarpaulin)"
                echo ""
                echo "With no arguments, runs: fmt check clippy test doc"
                echo ""
                return 0
                ;;
            *) print_error "Unknown CI step: $1"; return 1 ;;
        esac
    done

    # Default: all steps (except coverage)
    if [ ${#steps[@]} -eq 0 ]; then
        steps=(fmt check clippy test doc)
    fi

    print_header "CI Checks"
    local failed=false

    for step in "${steps[@]}"; do
        case "$step" in
            fmt)      run_fmt_check || failed=true ;;
            check)    print_status "Compile checking..."; (cd "$RUST_WORKSPACE" && cargo check --workspace --all-targets) && print_success "Check passed" || { print_error "Check failed"; failed=true; } ;;
            clippy)   run_clippy || failed=true ;;
            test)     run_tests || failed=true ;;
            doc)      run_doc_check || failed=true ;;
            coverage) run_coverage || failed=true ;;
        esac

        if [ "$failed" = true ]; then
            echo ""
            print_error "CI failed at: $step"
            return 1
        fi
    done

    echo ""
    print_success "All CI checks passed"
}

cmd_help() {
    echo ""
    echo -e "${CYAN}Tron - Persistent AI Coding Agent${NC}"
    echo ""
    echo "Usage: tron <command> [options]"
    echo ""
    echo "Development:"
    echo "  dev             Start server (-b build, -t test, -d background)"
    echo "  ci              Run CI checks (fmt, check, clippy, test, doc)"
    echo "  setup           First-time project setup"
    echo ""
    echo "Service:"
    echo "  start           Start launchd service"
    echo "  stop            Stop service"
    echo "  restart         Restart service"
    echo "  status          Show service status"
    echo ""
    echo "Deployment:"
    echo "  deploy          Build, test, deploy (--force to skip confirmations)"
    echo "  install         Initial setup (launchd + CLI)"
    echo "  rollback        Restore previous binary (--yes to skip confirmation)"
    echo "  uninstall       Remove service (preserves data)"
    echo ""
    echo "Auth:"
    echo "  login           Authenticate with Claude (--label <name> for multi-account)"
    echo ""
    echo "Logs:"
    echo "  logs            Query database logs (use -h for options)"
    echo "  errors          Show recent errors"
    echo ""
    echo "Direct cargo commands:"
    echo "  cd packages/agent-rs && cargo build --release"
    echo "  cd packages/agent-rs && cargo test --workspace"
    echo "  cd packages/agent-rs && cargo clippy --workspace -- -D warnings"
    echo ""
}

#=============================================================================
# SECTION 7: MAIN DISPATCH
#=============================================================================

ensure_tron_home

case "${1:-help}" in
    dev)       shift; cmd_dev "$@" ;;
    ci)        shift; cmd_ci "$@" ;;
    deploy)    shift; cmd_deploy "$@" ;;
    install)   cmd_install ;;
    rollback)  shift; cmd_rollback "$@" ;;
    setup)     shift; cmd_setup "$@" ;;
    status)    cmd_status ;;
    start)     cmd_start ;;
    stop)      cmd_stop ;;
    restart)   cmd_restart ;;
    logs)      shift; query_logs "$@" ;;
    errors)    cmd_errors ;;
    login)     shift; cmd_login "$@" ;;
    uninstall) cmd_uninstall ;;
    help|--help|-h) cmd_help ;;
    *) print_error "Unknown command: $1"; cmd_help; exit 1 ;;
esac
