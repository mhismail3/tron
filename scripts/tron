#!/bin/bash
# Tron service manager
# Manages production (launchd) and beta (terminal) environments

set -e

# Resolve symlinks to get the real script path
SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SOURCE" ]; do
    DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"

# Service configuration
PLIST_NAME="com.tron.server"
PLIST_PATH="$HOME/Library/LaunchAgents/$PLIST_NAME.plist"
TRON_HOME="${TRON_DATA_DIR:-$HOME/.tron}"
INSTALL_DIR="$TRON_HOME/app"
BIN_DIR="$HOME/.local/bin"
PROD_LOG_FILE="$INSTALL_DIR/server.log"
DEPLOYED_COMMIT_FILE="$INSTALL_DIR/deployed-commit"

# Port configuration
PROD_WS_PORT=8080
PROD_HEALTH_PORT=8081
BETA_WS_PORT=8082
BETA_HEALTH_PORT=8083

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

print_status() {
    echo -e "${BLUE}▸${NC} $1"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}!${NC} $1"
}

# Check if production service is running
is_running() {
    launchctl list 2>/dev/null | grep -q "$PLIST_NAME"
}

# Get PID of running service (from port listener)
get_pid() {
    lsof -t -i :$PROD_WS_PORT -sTCP:LISTEN 2>/dev/null || true
}

# Check if beta is running (by checking if port is in use)
is_beta_running() {
    lsof -i :$BETA_WS_PORT -sTCP:LISTEN >/dev/null 2>&1
}

# Get beta PID (from port listener)
get_beta_pid() {
    lsof -t -i :$BETA_WS_PORT -sTCP:LISTEN 2>/dev/null || true
}

cmd_status() {
    echo ""
    echo -e "${CYAN}Tron Service Status${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    # Production status
    if is_running; then
        local pid=$(get_pid)
        print_success "Production: ${GREEN}RUNNING${NC} (PID: ${pid:-unknown})"
        echo "  WebSocket: ws://localhost:$PROD_WS_PORT/ws"
        echo "  Health:    http://localhost:$PROD_HEALTH_PORT/health"

        # Show uptime if we can find the process
        if [ -n "$pid" ] && [ "$pid" != "-" ]; then
            local uptime=$(ps -o etime= -p "$pid" 2>/dev/null | tr -d ' ')
            if [ -n "$uptime" ]; then
                echo "  Uptime:    $uptime"
            fi
        fi

        # Check health endpoint
        local health_response
        health_response=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:$PROD_HEALTH_PORT/health" 2>/dev/null || echo "000")
        if [ "$health_response" = "200" ]; then
            echo -e "  Status:    ${GREEN}Healthy${NC}"
        else
            echo -e "  Status:    ${YELLOW}Not responding (HTTP $health_response)${NC}"
        fi

        # Show deployed commit
        if [ -f "$DEPLOYED_COMMIT_FILE" ]; then
            local deployed_commit=$(cat "$DEPLOYED_COMMIT_FILE")
            local commit_msg=$(cd "$PROJECT_DIR" && git log -1 --format="%s" "$deployed_commit" 2>/dev/null | head -c 50)
            echo "  Deployed:  ${deployed_commit:0:7} - $commit_msg"
        fi

        # Show install location
        if [ -d "$INSTALL_DIR" ]; then
            echo "  Install:   $INSTALL_DIR"
        fi
    else
        print_warning "Production: ${YELLOW}STOPPED${NC}"

        # Still show deployed commit if available
        if [ -f "$DEPLOYED_COMMIT_FILE" ]; then
            local deployed_commit=$(cat "$DEPLOYED_COMMIT_FILE")
            echo "  Last deployed: ${deployed_commit:0:7}"
        fi

        # Show install location if exists
        if [ -d "$INSTALL_DIR" ]; then
            echo "  Install:   $INSTALL_DIR"
        fi
    fi

    echo ""

    # Beta status
    local beta_pid=$(get_beta_pid)
    if [ -n "$beta_pid" ]; then
        print_success "Beta: ${GREEN}RUNNING${NC} (PID: $beta_pid)"
        echo "  WebSocket: ws://localhost:$BETA_WS_PORT/ws"
        echo "  Health:    http://localhost:$BETA_HEALTH_PORT/health"

        # Check beta health
        local beta_health
        beta_health=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:$BETA_HEALTH_PORT/health" 2>/dev/null || echo "000")
        if [ "$beta_health" = "200" ]; then
            echo -e "  Status:    ${GREEN}Healthy${NC}"
        else
            echo -e "  Status:    ${YELLOW}Not responding (HTTP $beta_health)${NC}"
        fi
    else
        echo -e "  Beta: not running"
    fi

    echo ""

    # Show log info
    echo -e "${DIM}Logs:${NC}"
    echo -e "  ${DIM}Query: tron logs [-l level] [-q search] [-s session]${NC}"
    if [ -f "$PROD_LOG_FILE" ]; then
        echo -e "  ${DIM}File:  $PROD_LOG_FILE${NC}"
    fi
    echo ""
}

cmd_start() {
    if is_running; then
        print_warning "Production service is already running"
        return 0
    fi

    if [ ! -f "$PLIST_PATH" ]; then
        print_error "Service not installed. Run: tron install"
        return 1
    fi

    print_status "Starting production service..."
    launchctl load "$PLIST_PATH"
    sleep 2

    if is_running; then
        print_success "Production service started"
        echo "  WebSocket: ws://localhost:$PROD_WS_PORT/ws"
        echo "  Health:    http://localhost:$PROD_HEALTH_PORT/health"
    else
        print_error "Failed to start service. Check: tron errors"
        return 1
    fi
}

cmd_stop() {
    if ! is_running; then
        print_warning "Production service is not running"
        return 0
    fi

    print_status "Stopping production service..."
    launchctl unload "$PLIST_PATH"
    sleep 1

    if ! is_running; then
        print_success "Production service stopped"
    else
        print_error "Failed to stop service"
        return 1
    fi
}

cmd_restart() {
    print_status "Restarting production service..."
    cmd_stop 2>/dev/null || true
    sleep 1
    cmd_start
}

cmd_logs() {
    local tier="prod"
    local level=""
    local output=""
    local limit=50
    local tail_mode=false
    local session=""
    local search=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -l|--level)
                level="$2"
                shift 2
                ;;
            -o|--output)
                output="$2"
                shift 2
                ;;
            -n|--limit)
                limit="$2"
                shift 2
                ;;
            -t|--tail)
                tail_mode=true
                shift
                ;;
            -s|--session)
                session="$2"
                shift 2
                ;;
            -q|--search)
                search="$2"
                shift 2
                ;;
            beta|prod)
                tier="$1"
                shift
                ;;
            -h|--help)
                echo ""
                echo -e "${CYAN}tron logs${NC} - Query database logs"
                echo ""
                echo "Usage: tron logs [options] [prod|beta]"
                echo ""
                echo "Options:"
                echo "  -l, --level LEVEL    Filter by level (trace/debug/info/warn/error/fatal)"
                echo "  -n, --limit N        Number of logs to show (default: 50)"
                echo "  -o, --output FILE    Write output to file"
                echo "  -s, --session ID     Filter by session ID"
                echo "  -q, --search TEXT    Search log messages (FTS)"
                echo "  -t, --tail           Tail file logs instead of querying database"
                echo "  -h, --help           Show this help"
                echo ""
                echo "Examples:"
                echo "  tron logs                     # Latest 50 logs"
                echo "  tron logs -l error            # Only errors"
                echo "  tron logs -l warn -n 100      # Last 100 warnings+"
                echo "  tron logs -o errors.txt -l error"
                echo "  tron logs -t                  # Tail file logs"
                echo "  tron logs beta -l info        # Beta database logs"
                echo ""
                return 0
                ;;
            *)
                shift
                ;;
        esac
    done

    # Tail mode - use prod file log
    if [ "$tail_mode" = true ]; then
        if [ ! -f "$PROD_LOG_FILE" ]; then
            print_error "Log file not found: $PROD_LOG_FILE"
            return 1
        fi

        echo -e "${BLUE}Tailing prod log${NC}"
        echo -e "${DIM}$PROD_LOG_FILE${NC}"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        tail -f "$PROD_LOG_FILE"
        return 0
    fi

    # Database mode - query SQLite
    local db_path="$TRON_HOME/events.db"
    if [ "$tier" = "beta" ]; then
        db_path="$TRON_HOME/beta/events.db"
    fi

    if [ ! -f "$db_path" ]; then
        print_error "Database not found: $db_path"
        echo "The server may not have been started yet, or no logs have been written."
        return 1
    fi

    # Check if logs table exists
    local table_exists
    table_exists=$(sqlite3 "$db_path" "SELECT name FROM sqlite_master WHERE type='table' AND name='logs';" 2>/dev/null)
    if [ -z "$table_exists" ]; then
        print_error "Logs table not found in database"
        echo "The server may need to be restarted with the updated schema."
        return 1
    fi

    # Build SQL query
    local where_clause=""
    local conditions=()

    if [ -n "$level" ]; then
        local level_num
        case "$level" in
            trace) level_num=10 ;;
            debug) level_num=20 ;;
            info)  level_num=30 ;;
            warn)  level_num=40 ;;
            error) level_num=50 ;;
            fatal) level_num=60 ;;
            *)
                print_error "Invalid level: $level"
                echo "Valid levels: trace, debug, info, warn, error, fatal"
                return 1
                ;;
        esac
        conditions+=("level_num >= $level_num")
    fi

    if [ -n "$session" ]; then
        conditions+=("session_id LIKE '%$session%'")
    fi

    if [ ${#conditions[@]} -gt 0 ]; then
        where_clause="WHERE $(IFS=' AND '; echo "${conditions[*]}")"
    fi

    local sql
    if [ -n "$search" ]; then
        # Use FTS search
        sql="SELECT l.timestamp, l.level, l.component, l.message, l.session_id, l.error_message
             FROM logs l
             JOIN logs_fts f ON l.id = f.log_id
             WHERE logs_fts MATCH '${search//\'/\'\'}'
             ${where_clause:+AND ${where_clause#WHERE }}
             ORDER BY l.timestamp DESC
             LIMIT $limit"
    else
        sql="SELECT timestamp, level, component, message, session_id, error_message
             FROM logs
             $where_clause
             ORDER BY timestamp DESC
             LIMIT $limit"
    fi

    # Execute query
    local result
    result=$(sqlite3 -separator '|' "$db_path" "$sql" 2>&1)

    if [ $? -ne 0 ]; then
        print_error "Database query failed: $result"
        return 1
    fi

    if [ -z "$result" ]; then
        echo -e "${DIM}No logs found matching criteria${NC}"
        return 0
    fi

    # Output
    if [ -n "$output" ]; then
        # Write to file (plain text, no colors)
        echo "$result" | while IFS='|' read -r ts lvl comp msg sess err; do
            local line="${ts} ${lvl} [${comp}] ${msg}"
            if [ -n "$sess" ]; then
                line="$line (${sess})"
            fi
            if [ -n "$err" ]; then
                line="$line | Error: $err"
            fi
            echo "$line"
        done > "$output"
        print_success "Wrote $(wc -l < "$output" | tr -d ' ') logs to $output"
    else
        # Display to terminal with colors
        echo -e "${CYAN}Database Logs ($tier)${NC}"
        echo -e "${DIM}Database: $db_path${NC}"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "$result" | while IFS='|' read -r ts lvl comp msg sess err; do
            local color=""
            case "$lvl" in
                trace) color="$DIM" ;;
                debug) color="$DIM" ;;
                info)  color="$GREEN" ;;
                warn)  color="$YELLOW" ;;
                error) color="$RED" ;;
                fatal) color="$RED$BOLD" ;;
            esac

            # Format timestamp (show time only)
            local time_part="${ts:11:8}"

            # Build output line
            local line="${time_part} ${color}${lvl}${NC} [${comp}] ${msg}"
            if [ -n "$sess" ]; then
                line="$line ${DIM}(${sess:0:12}...)${NC}"
            fi
            if [ -n "$err" ]; then
                line="$line\n  ${RED}Error: $err${NC}"
            fi

            echo -e "$line"
        done
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        local count=$(echo "$result" | wc -l | tr -d ' ')
        echo -e "${DIM}Showing $count logs (limit: $limit)${NC}"
    fi
}

cmd_errors() {
    local tier="${1:-prod}"
    local log_dir="$PROD_LOG_DIR"

    if [ "$tier" = "beta" ]; then
        log_dir="$BETA_LOG_DIR"
    fi

    if [ ! -d "$log_dir" ]; then
        print_error "Log directory not found: $log_dir"
        return 1
    fi

    # Find the most recent log file
    local latest_log
    latest_log=$(ls -t "$log_dir"/*.log 2>/dev/null | head -1)

    if [ -z "$latest_log" ]; then
        print_error "No log files found in $log_dir"
        return 1
    fi

    echo -e "${RED}Errors from: $(basename "$latest_log")${NC}"
    grep -i "error\|fatal\|exception" "$latest_log" | tail -50
}

cmd_beta() {
    # Check if beta is already running
    if is_beta_running; then
        print_warning "Beta server is already running on port $BETA_WS_PORT"
        echo "  Kill it first: kill $(get_beta_pid)"
        return 1
    fi

    # Build if needed
    if [ ! -d "$PROJECT_DIR/packages/server/dist" ]; then
        print_status "Building project..."
        cd "$PROJECT_DIR"
        npm run build
    fi

    # Create log directory
    mkdir -p "$BETA_LOG_DIR"

    # Generate timestamped log filename
    local timestamp=$(date +"%Y-%m-%d-%H")
    local log_file="$BETA_LOG_DIR/${timestamp}-beta-server.log"

    echo ""
    echo -e "${CYAN}Starting Beta Server${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "  WebSocket: ws://localhost:$BETA_WS_PORT/ws"
    echo "  Health:    http://localhost:$BETA_HEALTH_PORT/health"
    echo "  Database:  ~/.tron/events-beta.db"
    echo "  Log:       $log_file"
    echo ""
    echo -e "${YELLOW}Press Ctrl+C to stop${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    cd "$PROJECT_DIR"

    # Run with beta environment variables
    export TRON_WS_PORT=$BETA_WS_PORT
    export TRON_HEALTH_PORT=$BETA_HEALTH_PORT
    export TRON_BUILD_TIER=beta
    export TRON_EVENT_STORE_DB="$TRON_HOME/events-beta.db"
    export LOG_LEVEL="${TRON_LOG_LEVEL:-debug}"
    export NODE_ENV=development

    # Log startup and run server directly (not through TUI)
    echo "[$(date -Iseconds)] Starting Tron beta server" >> "$log_file"
    exec node packages/server/dist/index.js 2>&1 | tee -a "$log_file"
}

cmd_deploy() {
    echo ""
    echo -e "${CYAN}Deploying to Production${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    cd "$PROJECT_DIR"

    # Check if installed
    if [ ! -f "$PLIST_PATH" ]; then
        print_error "Tron not installed. Run: tron install"
        return 1
    fi

    # Check for uncommitted changes
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        print_warning "You have uncommitted changes!"
        echo ""
        git status --short
        echo ""
        read -p "Deploy anyway? (y/N) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_error "Aborted. Commit your changes first."
            return 1
        fi
    fi

    # Run tests first
    print_status "Running tests..."
    if ! bun run test 2>&1; then
        print_error "Tests failed! Aborting deploy."
        return 1
    fi
    print_success "Tests passed"

    # Build production bundle (includes TypeScript compilation)
    print_status "Building production bundle..."
    if ! "$SCRIPT_DIR/build-prod.sh" 2>&1; then
        print_error "Build failed! Aborting deploy."
        return 1
    fi
    print_success "Build complete"

    # Stop service if running
    if is_running; then
        print_status "Stopping production service..."
        launchctl unload "$PLIST_PATH" 2>/dev/null || true
        sleep 1
    fi

    # Copy production bundle to install directory
    print_status "Installing to $INSTALL_DIR..."
    rm -rf "$INSTALL_DIR"/*
    cp -r "$PROJECT_DIR/dist/prod/"* "$INSTALL_DIR/"
    print_success "Installed to: $INSTALL_DIR"

    # Record deployed commit
    local current_commit=$(git rev-parse HEAD)
    echo "$current_commit" > "$DEPLOYED_COMMIT_FILE"
    print_success "Recorded deploy: ${current_commit:0:7}"

    # Start service
    if [ -f "$PLIST_PATH" ]; then
        print_status "Starting production service..."
        launchctl load "$PLIST_PATH"
        sleep 3

        if is_running; then
            local pid=$(get_pid)
            print_success "Production service started (PID: ${pid:-unknown})"
        else
            print_error "Failed to start service. Check: tron logs"
            return 1
        fi
    else
        print_warning "Service not installed. Run: tron install"
    fi

    echo ""
    print_success "Deploy complete!"
    echo ""
}

cmd_rollback() {
    echo ""
    echo -e "${CYAN}Rolling Back to Last Deployed State${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    cd "$PROJECT_DIR"

    # Check if we have a deployed commit recorded
    if [ ! -f "$DEPLOYED_COMMIT_FILE" ]; then
        print_error "No deployed commit found. Cannot rollback."
        echo "  Run 'tron deploy' first to record a deployment."
        return 1
    fi

    local deployed_commit=$(cat "$DEPLOYED_COMMIT_FILE")
    local deployed_msg=$(git log -1 --format="%s" "$deployed_commit" 2>/dev/null | head -c 60)
    local current_commit=$(git rev-parse HEAD)

    # Check if we're already at the deployed commit
    if [ "$current_commit" = "$deployed_commit" ]; then
        print_success "Already at deployed commit: ${deployed_commit:0:7}"
        return 0
    fi

    echo "  Current:  ${current_commit:0:7} - $(git log -1 --format='%s' HEAD | head -c 50)"
    echo "  Deployed: ${deployed_commit:0:7} - $deployed_msg"
    echo ""

    # Check for uncommitted changes
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        print_warning "You have uncommitted changes that will be stashed!"
        echo ""
        git status --short
        echo ""
    fi

    read -p "Reset working directory to deployed commit? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_error "Aborted."
        return 1
    fi

    # Stash any changes just in case
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        print_status "Stashing uncommitted changes (retrievable with 'git stash pop')..."
        git stash push -m "Auto-stash before rollback to $deployed_commit"
    fi

    # Reset to deployed commit
    print_status "Resetting to ${deployed_commit:0:7}..."
    git checkout "$deployed_commit" -- .
    git reset HEAD
    print_success "Working directory restored"

    # Build production bundle
    print_status "Building production bundle..."
    "$SCRIPT_DIR/build-prod.sh"
    print_success "Build complete"

    # Redeploy
    print_status "Redeploying to $INSTALL_DIR..."

    # Stop service if running
    if is_running; then
        launchctl unload "$PLIST_PATH" 2>/dev/null || true
        sleep 1
    fi

    # Copy production bundle to install directory
    rm -rf "$INSTALL_DIR"/*
    cp -r "$PROJECT_DIR/dist/prod/"* "$INSTALL_DIR/"

    # Restore deployed commit file
    echo "$deployed_commit" > "$DEPLOYED_COMMIT_FILE"

    # Start service
    if [ -f "$PLIST_PATH" ]; then
        launchctl load "$PLIST_PATH"
        sleep 3
        if is_running; then
            print_success "Production service restarted"
        else
            print_error "Failed to restart service"
        fi
    fi

    echo ""
    print_success "Rollback complete! Now at: ${deployed_commit:0:7}"
    echo ""
}

cmd_install() {
    echo ""
    echo -e "${CYAN}Installing Tron Service${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    # Ensure directories exist
    mkdir -p "$BIN_DIR"
    mkdir -p "$TRON_HOME"
    mkdir -p "$INSTALL_DIR"
    mkdir -p "$PROD_LOG_DIR"
    mkdir -p "$BETA_LOG_DIR"
    mkdir -p "$HOME/Library/LaunchAgents"

    # Build production bundle if needed
    if [ ! -f "$PROJECT_DIR/dist/prod/index.js" ]; then
        print_status "Building production bundle..."
        cd "$PROJECT_DIR"
        "$SCRIPT_DIR/build-prod.sh"
    fi

    # Copy production bundle to install directory
    print_status "Installing to $INSTALL_DIR..."
    rm -rf "$INSTALL_DIR"/*
    cp -r "$PROJECT_DIR/dist/prod/"* "$INSTALL_DIR/"
    print_success "Installed to: $INSTALL_DIR"

    # Get node path
    local node_path
    node_path=$(which node)

    # Create launchd plist - runs the bundled server
    print_status "Creating launchd service..."
    cat > "$PLIST_PATH" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>$PLIST_NAME</string>

    <key>ProgramArguments</key>
    <array>
        <string>/bin/sh</string>
        <string>-c</string>
        <string>exec "$node_path" "$INSTALL_DIR/index.js" >> "$PROD_LOG_DIR/server.log" 2>&1</string>
    </array>

    <key>WorkingDirectory</key>
    <string>$INSTALL_DIR</string>

    <key>RunAtLoad</key>
    <true/>

    <key>KeepAlive</key>
    <dict>
        <key>SuccessfulExit</key>
        <false/>
        <key>Crashed</key>
        <true/>
    </dict>

    <key>ThrottleInterval</key>
    <integer>10</integer>

    <key>EnvironmentVariables</key>
    <dict>
        <key>NODE_ENV</key>
        <string>production</string>
        <key>TRON_BUILD_TIER</key>
        <string>prod</string>
        <key>HOME</key>
        <string>$HOME</string>
        <key>PATH</key>
        <string>$(dirname "$node_path"):/usr/local/bin:/usr/bin:/bin</string>
        <key>TRON_DATA_DIR</key>
        <string>$TRON_HOME</string>
        <key>TRON_WS_PORT</key>
        <string>$PROD_WS_PORT</string>
        <key>TRON_HEALTH_PORT</key>
        <string>$PROD_HEALTH_PORT</string>
        <key>LOG_LEVEL</key>
        <string>info</string>
    </dict>

    <key>SoftResourceLimits</key>
    <dict>
        <key>NumberOfFiles</key>
        <integer>4096</integer>
    </dict>
</dict>
</plist>
EOF
    print_success "Created: $PLIST_PATH"

    # Install CLI symlink
    print_status "Installing tron CLI..."
    ln -sf "$SCRIPT_DIR/tron" "$BIN_DIR/tron"
    print_success "Installed: $BIN_DIR/tron"

    # Check if ~/.local/bin is in PATH
    if [[ ":$PATH:" != *":$BIN_DIR:"* ]]; then
        print_warning "Add to your shell profile: export PATH=\"\$HOME/.local/bin:\$PATH\""
    fi

    # Record initial deploy
    local current_commit=$(cd "$PROJECT_DIR" && git rev-parse HEAD 2>/dev/null || echo "unknown")
    echo "$current_commit" > "$DEPLOYED_COMMIT_FILE"

    # Start the service
    print_status "Starting service..."
    launchctl load "$PLIST_PATH"
    sleep 3

    if is_running; then
        local pid=$(get_pid)
        print_success "Service started! (PID: ${pid:-unknown})"
    else
        print_error "Service failed to start. Check: tron logs"
    fi

    echo ""
    print_success "Installation complete!"
    echo ""
    echo "Locations:"
    echo "  Install:   $INSTALL_DIR"
    echo "  Logs:      $PROD_LOG_DIR"
    echo "  Data:      $TRON_HOME"
    echo ""
    echo "Commands:"
    echo "  tron status    - Check service status"
    echo "  tron logs      - View production logs"
    echo "  tron beta      - Run beta server (port $BETA_WS_PORT)"
    echo "  tron deploy    - Build and deploy to production"
    echo ""
}

cmd_uninstall() {
    echo ""
    echo -e "${CYAN}Uninstalling Tron Service${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    if is_running; then
        print_status "Stopping service..."
        launchctl unload "$PLIST_PATH" 2>/dev/null || true
        sleep 1
    fi

    print_status "Removing launchd service..."
    rm -f "$PLIST_PATH"

    print_status "Removing CLI..."
    rm -f "$BIN_DIR/tron"

    print_status "Removing installed app..."
    rm -rf "$INSTALL_DIR"

    echo ""
    print_success "Service uninstalled"
    print_warning "Data preserved in: $TRON_HOME"
    print_warning "Logs preserved in: $TRON_HOME/logs/"
    echo ""
}

cmd_help() {
    echo ""
    echo -e "${CYAN}Tron - Persistent Coding Agent${NC}"
    echo ""
    echo "Usage: tron <command>"
    echo ""
    echo "Service Commands:"
    echo "  status      Show service status and health"
    echo "  start       Start production service"
    echo "  stop        Stop production service"
    echo "  restart     Restart production service"
    echo "  logs        Query database logs (use -h for options)"
    echo "  errors      Show recent errors from file logs"
    echo ""
    echo "Development:"
    echo "  beta        Run beta server (port $BETA_WS_PORT, separate database)"
    echo "  deploy      Test, build, and deploy to production"
    echo "  rollback    Restore working directory to last deployed commit"
    echo ""
    echo "Setup:"
    echo "  install     Install launchd service and CLI"
    echo "  uninstall   Remove service (preserves data)"
    echo ""
    echo "Log Examples:"
    echo "  tron logs                  # Latest 50 database logs"
    echo "  tron logs -l error         # Errors and fatals only"
    echo "  tron logs -l warn -n 100   # Last 100 warnings+"
    echo "  tron logs -t               # Tail file logs (live)"
    echo "  tron logs -o out.txt       # Write to file"
    echo ""
    echo "Ports:"
    echo "  Production: WS $PROD_WS_PORT, Health $PROD_HEALTH_PORT"
    echo "  Beta:       WS $BETA_WS_PORT, Health $BETA_HEALTH_PORT"
    echo ""
}

# Main
case "${1:-}" in
    status)     cmd_status ;;
    start)      cmd_start ;;
    stop)       cmd_stop ;;
    restart)    cmd_restart ;;
    logs)       shift; cmd_logs "$@" ;;
    errors)     cmd_errors "${2:-}" ;;
    beta)       cmd_beta ;;
    deploy)     cmd_deploy ;;
    rollback)   cmd_rollback ;;
    install)    cmd_install ;;
    uninstall)  cmd_uninstall ;;
    help|--help|-h|"")
        cmd_help
        ;;
    *)
        print_error "Unknown command: $1"
        cmd_help
        exit 1
        ;;
esac
