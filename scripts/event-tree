#!/bin/bash
#
# event-tree - Visualize Tron event tree structure with fork points
#
# Usage:
#   event-tree                    # Show all sessions and their event trees
#   event-tree -s <session_id>    # Show specific session
#   event-tree -w                 # Watch mode (real-time updates)
#   event-tree -w -s <session_id> # Watch specific session
#   event-tree --stats            # Show database stats only
#   event-tree --forks            # Show only fork points and session lineage
#

set -euo pipefail

DB_PATH="${TRON_DB_PATH:-$HOME/.tron/events.db}"
WATCH_MODE=false
SESSION_FILTER=""
STATS_ONLY=false
FORKS_ONLY=false
WATCH_INTERVAL=1

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
GRAY='\033[0;90m'
BOLD='\033[1m'
DIM='\033[2m'
RESET='\033[0m'

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -w|--watch)
            WATCH_MODE=true
            shift
            ;;
        -s|--session)
            SESSION_FILTER="$2"
            shift 2
            ;;
        --stats)
            STATS_ONLY=true
            shift
            ;;
        --forks)
            FORKS_ONLY=true
            shift
            ;;
        -i|--interval)
            WATCH_INTERVAL="$2"
            shift 2
            ;;
        -h|--help)
            echo "Usage: event-tree [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  -s, --session ID   Show specific session"
            echo "  -w, --watch        Watch mode (real-time updates)"
            echo "  -i, --interval N   Watch interval in seconds (default: 1)"
            echo "  --stats            Show database stats only"
            echo "  --forks            Show only fork points and session lineage"
            echo "  -h, --help         Show this help"
            echo ""
            echo "Environment:"
            echo "  TRON_DB_PATH       Database path (default: ~/.tron/events.db)"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Check if database exists
if [[ ! -f "$DB_PATH" ]]; then
    echo -e "${RED}Error: Database not found at $DB_PATH${RESET}"
    echo "Set TRON_DB_PATH or ensure ~/.tron/events.db exists"
    exit 1
fi

# SQL helper
sql() {
    sqlite3 -separator '|' "$DB_PATH" "$1" 2>/dev/null || true
}

# Show database stats
show_stats() {
    echo -e "${BOLD}╔══════════════════════════════════════════════════════════════╗${RESET}"
    echo -e "${BOLD}║                    TRON EVENT DATABASE                       ║${RESET}"
    echo -e "${BOLD}╚══════════════════════════════════════════════════════════════╝${RESET}"
    echo ""

    local total_events=$(sql "SELECT COUNT(*) FROM events;")
    local total_sessions=$(sql "SELECT COUNT(*) FROM sessions;")
    local active_sessions=$(sql "SELECT COUNT(*) FROM sessions WHERE status = 'active';")
    local total_workspaces=$(sql "SELECT COUNT(*) FROM workspaces;")
    local total_forks=$(sql "SELECT COUNT(*) FROM sessions WHERE parent_session_id IS NOT NULL;")
    local total_branches=$(sql "SELECT COUNT(*) FROM branches;")
    local db_size=$(du -h "$DB_PATH" | cut -f1)

    echo -e "${CYAN}Database:${RESET} $DB_PATH ($db_size)"
    echo ""
    echo -e "${BOLD}Stats:${RESET}"
    echo -e "  Events:      ${GREEN}$total_events${RESET}"
    echo -e "  Sessions:    ${GREEN}$total_sessions${RESET} (${YELLOW}$active_sessions active${RESET})"
    echo -e "  Workspaces:  ${GREEN}$total_workspaces${RESET}"
    echo -e "  Forks:       ${MAGENTA}$total_forks${RESET}"
    echo -e "  Branches:    ${BLUE}$total_branches${RESET}"
    echo ""
}

# Show session lineage using recursive CTE
show_session_lineage() {
    echo -e "${BOLD}Session Lineage (Fork Relationships):${RESET}"
    echo ""

    # Use simpler recursive CTE without window functions
    local tree_output=$(sql "
        WITH RECURSIVE session_tree(id, title, status, parent_session_id, fork_from_event_id, event_count, total_cost, created_at, workspace, level, path) AS (
            -- Root sessions (no parent)
            SELECT
                s.id,
                COALESCE(s.title, 'Untitled'),
                s.status,
                '',
                COALESCE(s.fork_from_event_id, ''),
                s.event_count,
                COALESCE(s.total_cost, 0),
                datetime(s.created_at),
                COALESCE(w.name, 'unknown'),
                0,
                s.id
            FROM sessions s
            LEFT JOIN workspaces w ON s.workspace_id = w.id
            WHERE s.parent_session_id IS NULL

            UNION ALL

            -- Child sessions (forks)
            SELECT
                s.id,
                COALESCE(s.title, 'Untitled'),
                s.status,
                s.parent_session_id,
                COALESCE(s.fork_from_event_id, ''),
                s.event_count,
                COALESCE(s.total_cost, 0),
                datetime(s.created_at),
                COALESCE(w.name, 'unknown'),
                st.level + 1,
                st.path || '/' || s.id
            FROM sessions s
            LEFT JOIN workspaces w ON s.workspace_id = w.id
            JOIN session_tree st ON s.parent_session_id = st.id
        )
        SELECT id, title, status, parent_session_id, fork_from_event_id, event_count, total_cost, created_at, workspace, level
        FROM session_tree
        ORDER BY path, created_at;
    ")

    if [[ -z "$tree_output" ]]; then
        echo -e "${DIM}No sessions found${RESET}"
        return
    fi

    # Print each session with proper indentation
    while IFS='|' read -r id title status parent_id fork_event_id event_count total_cost created_at workspace level; do
        # Build indentation
        local indent=""
        for ((i=0; i<level; i++)); do
            indent+="    "
        done

        # Session icon (fork or root)
        local icon="○"
        local connector=""
        if [[ -n "$parent_id" && "$parent_id" != "" ]]; then
            icon="${MAGENTA}⑂${RESET}"
            connector="└── "
        fi

        # Status color
        local status_color="$GRAY"
        case "$status" in
            active) status_color="$GREEN" ;;
            ended) status_color="$YELLOW" ;;
            archived) status_color="$GRAY" ;;
        esac

        # Format cost
        local cost_display=""
        if [[ -n "$total_cost" && "$total_cost" != "0" && "$total_cost" != "0.0" ]]; then
            cost_display=" | Cost: ${YELLOW}\$${total_cost}${RESET}"
        fi

        # Print session header
        echo -e "${indent}${connector}${icon} ${BOLD}${CYAN}${id}${RESET}"
        echo -e "${indent}    ${DIM}├─${RESET} ${BOLD}${title}${RESET}"
        echo -e "${indent}    ${DIM}├─${RESET} Status: ${status_color}${status}${RESET} | Events: ${GREEN}${event_count}${RESET}${cost_display}"

        if [[ -n "$fork_event_id" && "$fork_event_id" != "" ]]; then
            echo -e "${indent}    ${DIM}├─${RESET} ${MAGENTA}Forked from:${RESET} ${fork_event_id:0:16}..."
        fi

        echo -e "${indent}    ${DIM}└─${RESET} ${GRAY}${workspace} @ ${created_at}${RESET}"
        echo ""
    done <<< "$tree_output"
}

# Show event tree for a specific session
show_event_tree() {
    local session_id="$1"

    # Get session info
    local session_info=$(sql "
        SELECT
            s.id,
            COALESCE(s.title, 'Untitled'),
            s.status,
            s.event_count,
            COALESCE(s.head_event_id, ''),
            COALESCE(s.root_event_id, ''),
            COALESCE(s.fork_from_event_id, ''),
            COALESCE(w.name, 'unknown'),
            COALESCE(s.total_cost, 0)
        FROM sessions s
        LEFT JOIN workspaces w ON s.workspace_id = w.id
        WHERE s.id = '$session_id';
    ")

    if [[ -z "$session_info" ]]; then
        echo -e "${RED}Session not found: $session_id${RESET}"
        return
    fi

    IFS='|' read -r id title status event_count head_event_id root_event_id fork_from_event workspace total_cost <<< "$session_info"

    # Format cost display
    local cost_display=""
    if [[ -n "$total_cost" && "$total_cost" != "0" && "$total_cost" != "0.0" ]]; then
        cost_display=" | Cost: ${YELLOW}\$${total_cost}${RESET}"
    fi

    echo -e "${BOLD}Session: ${CYAN}$id${RESET}"
    echo -e "  Title: ${BOLD}$title${RESET}"
    echo -e "  Status: $status | Events: $event_count${cost_display} | Workspace: $workspace"
    if [[ -n "$fork_from_event" && "$fork_from_event" != "" ]]; then
        echo -e "  ${MAGENTA}Forked from: $fork_from_event${RESET}"
    fi
    echo ""
    echo -e "${BOLD}Event Tree:${RESET}"
    echo ""

    # Get events with fork point detection
    local events=$(sql "
        WITH child_counts AS (
            SELECT parent_id, COUNT(*) as cnt
            FROM events
            WHERE session_id = '$session_id' AND parent_id IS NOT NULL
            GROUP BY parent_id
        )
        SELECT
            e.id,
            COALESCE(e.parent_id, '') as parent_id,
            e.sequence,
            e.depth,
            e.type,
            COALESCE(e.role, '') as role,
            COALESCE(e.tool_name, '') as tool_name,
            SUBSTR(e.timestamp, 12, 8) as time,
            CASE WHEN e.id = '$head_event_id' THEN 1 ELSE 0 END as is_head,
            COALESCE(cc.cnt, 0) as child_count
        FROM events e
        LEFT JOIN child_counts cc ON cc.parent_id = e.id
        WHERE e.session_id = '$session_id'
        ORDER BY e.sequence ASC;
    ")

    if [[ -z "$events" ]]; then
        echo -e "${DIM}No events${RESET}"
        return
    fi

    # Print events with tree visualization
    while IFS='|' read -r id parent_id seq depth type role tool_name time is_head child_count; do
        # Type-based icon and color
        local icon="●"
        local color="$RESET"

        case "$type" in
            session.start) icon="◆"; color="$GREEN" ;;
            session.end) icon="◇"; color="$YELLOW" ;;
            session.fork) icon="⑂"; color="$MAGENTA" ;;
            message.user) icon="→"; color="$BLUE" ;;
            message.assistant) icon="←"; color="$CYAN" ;;
            tool.call) icon="⚡"; color="$YELLOW" ;;
            tool.result) icon="✓"; color="$GREEN" ;;
            stream.text_delta|stream.thinking_delta) icon="~"; color="$DIM" ;;
            stream.turn_start|stream.turn_end) icon="↻"; color="$GRAY" ;;
            error.*) icon="✗"; color="$RED" ;;
            *) icon="○"; color="$GRAY" ;;
        esac

        # Build indentation based on depth
        local indent=""
        for ((i=0; i<depth; i++)); do
            indent+="│   "
        done

        # Fork point marker
        local fork_marker=""
        if [[ "$child_count" -gt 1 ]]; then
            fork_marker=" ${MAGENTA}⑂ FORK (${child_count} branches)${RESET}"
        fi

        # Head marker
        local head_marker=""
        if [[ "$is_head" == "1" ]]; then
            head_marker=" ${GREEN}← HEAD${RESET}"
        fi

        # Print event line
        local short_id="${id:0:8}"
        local type_short="${type#*.}"  # Remove prefix before .

        printf "${indent}${color}${icon}${RESET} ${DIM}%s${RESET} ${BOLD}%-18s${RESET}" "$short_id" "$type_short"

        # Add role/tool info
        if [[ -n "$tool_name" && "$tool_name" != "" ]]; then
            printf " ${YELLOW}[%s]${RESET}" "$tool_name"
        elif [[ -n "$role" && "$role" != "" ]]; then
            printf " ${GRAY}(%s)${RESET}" "$role"
        fi

        printf " ${DIM}%s${RESET}" "$time"
        printf "%s%s\n" "$fork_marker" "$head_marker"

    done <<< "$events"
}

# Show all sessions with their event trees
show_all() {
    show_stats

    if [[ "$STATS_ONLY" == "true" ]]; then
        return
    fi

    echo "─────────────────────────────────────────────────────────────────"
    echo ""

    if [[ "$FORKS_ONLY" == "true" ]]; then
        show_session_lineage
        return
    fi

    # If a specific session is requested
    if [[ -n "$SESSION_FILTER" ]]; then
        show_event_tree "$SESSION_FILTER"
        return
    fi

    # Show session lineage first
    show_session_lineage

    echo "─────────────────────────────────────────────────────────────────"
    echo ""

    # Show recent sessions with their event trees
    echo -e "${BOLD}Recent Event Trees (last 3 active sessions):${RESET}"
    echo ""

    local recent_sessions=$(sql "
        SELECT id FROM sessions
        WHERE status = 'active'
        ORDER BY last_activity_at DESC
        LIMIT 3;
    ")

    while IFS= read -r session_id; do
        if [[ -n "$session_id" ]]; then
            show_event_tree "$session_id"
            echo ""
            echo "─────────────────────────────────────────────────────────────────"
            echo ""
        fi
    done <<< "$recent_sessions"
}

# Watch mode
watch_loop() {
    local last_event_count=0
    local last_session_count=0

    while true; do
        clear
        echo -e "${DIM}Watching... (Ctrl+C to exit, updating every ${WATCH_INTERVAL}s)${RESET}"
        echo -e "${DIM}Last update: $(date '+%H:%M:%S')${RESET}"
        echo ""

        local current_event_count=$(sql "SELECT COUNT(*) FROM events;")
        local current_session_count=$(sql "SELECT COUNT(*) FROM sessions;")

        # Show change indicators
        if [[ "$current_event_count" -gt "$last_event_count" ]] && [[ "$last_event_count" -gt 0 ]]; then
            local new_events=$((current_event_count - last_event_count))
            echo -e "${GREEN}▲ $new_events new event(s)${RESET}"
        fi

        if [[ "$current_session_count" -gt "$last_session_count" ]] && [[ "$last_session_count" -gt 0 ]]; then
            local new_sessions=$((current_session_count - last_session_count))
            echo -e "${MAGENTA}▲ $new_sessions new session(s) / fork(s)${RESET}"
        fi

        echo ""

        show_all

        last_event_count=$current_event_count
        last_session_count=$current_session_count

        sleep "$WATCH_INTERVAL"
    done
}

# Main
if [[ "$WATCH_MODE" == "true" ]]; then
    watch_loop
else
    show_all
fi
